<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://miuyou.github.io/</id>
    <title>春待ち</title>
    <updated>2020-03-12T08:56:16.590Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://miuyou.github.io/"/>
    <link rel="self" href="https://miuyou.github.io/atom.xml"/>
    <subtitle>开端顺利 自这天起 离乡背井 等候春息  身处何地 等候春息</subtitle>
    <logo>https://miuyou.github.io/images/avatar.png</logo>
    <icon>https://miuyou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 春待ち</rights>
    <entry>
        <title type="html"><![CDATA[Miu_you の 区间DP]]></title>
        <id>https://miuyou.github.io/post/miu_you-no-qu-jian-dp/</id>
        <link href="https://miuyou.github.io/post/miu_you-no-qu-jian-dp/">
        </link>
        <updated>2020-03-11T09:23:08.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miuyou.github.io//post-images/1583918620293.jpg" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miuyou.github.io//post-images/1583918620293.jpg" alt="" loading="lazy"></figure>
<!-- more -->
<p>区间DP就显得没那么有趣了,下面放一些做过的题就好啦</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1864">P1864 [NOI2009]二叉查找树</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2145">P2145 [JSOI2007]祖码</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2466">P2466 [SDOI2008]Sue的小球</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2470">P2470 [SCOI2007]压缩</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4290">P4290 [HAOI2008]玩具取名</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4302">P4302 [SCOI2003]字符串折叠</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4342">P4342 [IOI1998]Polygon</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4766">P4766 [CERC2014]Outer space invaders</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4767">P4767 [IOI2000]邮局</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Miu_youの思维题]]></title>
        <id>https://miuyou.github.io/post/miu_younosi-wei-ti/</id>
        <link href="https://miuyou.github.io/post/miu_younosi-wei-ti/">
        </link>
        <updated>2020-03-09T10:03:59.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miuyou.github.io//post-images/1583748331912.png" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miuyou.github.io//post-images/1583748331912.png" alt="" loading="lazy"></figure>
<!-- more -->
<p>恶心人不偿命的思维题,这里用来收录不知道放到哪里去的好题</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3943">P3943 星空</a><br>
考虑到为了快速反转区间,可以对他做一个差分.....具体过段时间来写.00000</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2007]梦幻岛宝珠 题解]]></title>
        <id>https://miuyou.github.io/post/hnoi2007meng-huan-dao-bao-zhu-ti-jie/</id>
        <link href="https://miuyou.github.io/post/hnoi2007meng-huan-dao-bao-zhu-ti-jie/">
        </link>
        <updated>2020-03-09T00:58:33.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/iskee2vp.png" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/iskee2vp.png" alt="" loading="lazy"></figure>
<!-- more -->
<p>这题看起来只是一个01背包,但是庞大的数据范围告诉我们常规手段无法解决.</p>
<p>容量非常大,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>,没有任何的通用优化手段可以解决,但是发现每个物品的容量都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>∗</mo><msup><mn>2</mn><mi>b</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(a*2^{b})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,同时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>很小,考虑先分层,将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>作为分层的依据,且最多分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>层,考虑对于每一层进行01DP,然后再合并每一层的dp值.</p>
<p>这里用到了泛化的思想,合并dp值在正整数域的情况下是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的.考虑合并时,总容量为之前所有层的容量之和.</p>
<p>这题的基本思路其他题解已经写的很好了,感谢他们的工作.但是稍微有一些遗憾.</p>
<p>1.合并的原理是什么?</p>
<p>关于泛化的概念可以去看背包九讲,因为这里的容量是基于正整数域的,那么我们需要将两组dp数值两两合并.</p>
<p>参照背包九讲的说法:&quot;如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值.怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0..</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">0..V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>的每一个整数v，可以求得费用v分配到h和l中的最大价值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。也即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>v</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>h</mi><mi>k</mi></msub><mo>+</mo><msub><mi>l</mi><mrow><mi>v</mi><mo>−</mo><mi>k</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(v)=max(h_k+l_{v-k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>k</mi><mo>&lt;</mo><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">0&lt;=k&lt;=v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>。可以看到，f也是一个由泛化物品h和l决定的定义域为0..V的函数，也就是说，f是一个由泛化物品h和l决定的泛化物品。&quot;</p>
<p>按照这个思想,我们就能进行如下合并</p>
<pre><code class="language-cpp">for (int j = sum[i]; j &gt; -1; --j) {
				for (int k = 0; k &lt;= j; ++k) {
					dp[i][j] = max(dp[i][j], dp[i][j - k] + dp[i - 1][min(sum[i - 1], (k &lt;&lt; 1) | ((m &gt;&gt; (i - 1)) &amp; 1))]);
				}
			}
</code></pre>
<p>直接套模板就行了,但是<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 18: …(m &gt;&gt; (i - 1)) &amp;̲ 1)'>(((m &gt;&gt; (i - 1)) &amp; 1)</span>这是个啥???<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k&lt;&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>是分配给h的容量的,分配了k个单位,然后因为退位了所以乘以二,但是还有一部分容量没有被计算,那就是背包容量在当前位的单位,所以判断一下m的当前位是否为1.</p>
<p>2.每一层的单位总量是什么?<br>
代码中有这么一句</p>
<pre><code class="language-cpp">sum[i] += (sum[i - 1] + 1) / 2;
</code></pre>
<p>为什么要加一?<br>
如果现在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">sum[i]==0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">sum[i-1]==1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,如果向下取整,那么在i这一层无法合并第i-1层,所以应当向上取整,不怕多只怕少(雾</p>
<p>下面就是完整代码了</p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_DEPRECATE
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
using namespace std;
int n, m, maxx;
int sum[35];
long long dp[35][1050];
vector&lt;int&gt;w[35], v[35];
inline int lowbit(int x) {
	return x &amp; (-x);
}
int main() {
	while (1) {
		memset(sum, 0, sizeof(sum));
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
		if (n == -1 &amp;&amp; m == -1)return 0;
		maxx = 0;
		memset(dp, 0, sizeof(dp));
		for (int i = 1; i &lt;= n; ++i) {
			int x, y;
			scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
			int k = 0;
			while (!(x &amp; 1)) {
				x &gt;&gt;= 1;
				++k;
				if (!x)break;
			}w[k].push_back(x);
			sum[k] += x;
			maxx = max(maxx, k);
			v[k].push_back(y);
		}

		for (int i = 0; i &lt;= maxx; ++i) {
			for (int j = 0; j &lt; w[i].size(); ++j) {
				for (int k = sum[i]; k &gt;= w[i][j]; --k) {
					dp[i][k] = max(dp[i][k], dp[i][k - w[i][j]] + v[i][j]);
				}
			}
		}
		while (m &gt;&gt; maxx)++maxx; --maxx;
		for (int i = 1; i &lt;= maxx; ++i) {
			sum[i] += (sum[i - 1] + 1) / 2;
			for (int j = sum[i]; j &gt; -1; --j) {
				for (int k = 0; k &lt;= j; ++k) {
					dp[i][j] = max(dp[i][j], dp[i][j - k] + dp[i - 1][min(sum[i - 1], (k &lt;&lt; 1) | ((m &gt;&gt; (i - 1)) &amp; 1))]);
				}
			}
			//考虑一个事情,我们当前停留的位置到底在哪里,例如一个110101   如果现在在第5位   j={1,2,3},发现后面还有一串没有分配
		}

		cout &lt;&lt; dp[maxx][1] &lt;&lt; endl;
		for (int i = 0; i &lt;= 30; ++i) {
			v[i].clear();
			w[i].clear();
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Miu_you の 最小生成树]]></title>
        <id>https://miuyou.github.io/post/miu_you-no-zui-xiao-sheng-cheng-shu/</id>
        <link href="https://miuyou.github.io/post/miu_you-no-zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-03-08T14:18:11.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miuyou.github.io//post-images/1583677126629.jpg" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miuyou.github.io//post-images/1583677126629.jpg" alt="" loading="lazy"></figure>
<!-- more -->
<h2 id="最小生成树-有趣の题目">最小生成树 有趣の题目</h2>
<h2 id="求特定边权和最小生成树">求特定边权和最小生成树</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3623">P3623 [APIO2008]免费道路</a><br>
考虑到免费道路一定是n-1条,那么将边权取反,即为求一个边权和为k的最小生成树.先做一个最小生成树,如果边权超过k无解,若边权小于k,那么先填满k条有权边,如果不够的话无解,再生成最小生成树.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Miu_you の进阶背包DP]]></title>
        <id>https://miuyou.github.io/post/miu_you-nobei-bao-dp/</id>
        <link href="https://miuyou.github.io/post/miu_you-nobei-bao-dp/">
        </link>
        <updated>2020-03-07T10:29:54.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miuyou.github.io//post-images/1583577043309.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>即使是最普通的背包,也是非常值得深思的.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miuyou.github.io//post-images/1583577043309.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>即使是最普通的背包,也是非常值得深思的.</p>
</blockquote>
<!-- more -->
<h2 id="1单调队列优化背包">1.单调队列优化背包</h2>
<p>我们知道,一般の背包做法是枚举物品和物品个数/当前容量,复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>W</mi><mo>∗</mo><msubsup><mo>∑</mo><mrow><mn>1</mn><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>m</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*W*\sum_{1=1}^{n}m_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,效率非常底下,因为枚举背包容量无法避免,那么考虑如何优化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>m</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(\sum_{i=1}^{n}m_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>考虑到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><msub><mi>p</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi>w</mi></mrow></msub><mo>+</mo><mi>k</mi><mo>∗</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">dp_i=max(dp_i,dp_{i-k*w}+k*v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>,发现什么了没有?你看看这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i%w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,所有能够改变这个i的状态,已使用背包容量对w取模后都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i \bmod w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>,设这个余数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>k</mi><mo>∗</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">i=x+k*w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>.</p>
<p>此时将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dp_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的决策集合大小减小到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>W</mi><mo>−</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">/</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">(W-x)/w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>,此时暴力的复杂度得到了一个不错的优化,但是非常玄学且依旧低效.考虑到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>W</mi><mo>−</mo><mi>x</mi><mo>)</mo><mi mathvariant="normal">/</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">(W-x)/w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>这个集合不仅仅只能更新一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dp_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,而是能够更新所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>w</mi><mo>=</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i \bmod w=x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>的值,为了高效维护更新集合的最大值及有效值,可以考虑使用单调队列来维护这个集合.接下来就是常规操作啦!</p>
<p>例题:</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1776">P1776 宝物筛选</a></li>
</ul>
<p>上面讲过啦!</p>
<h2 id="第k优解背包">第k优解背包</h2>
<p>考虑到每次刷新背包的dp值,都是用一个较优的替代较劣的,那么考虑将一维dp数组扩展一维,用来存放第k优解,因为第k优解很明显和第k-1优解有关,每个物品加入的时候产生的总情况为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>v</mi><mo>)</mo><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">(V-v)*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,但是考虑到两个集合都是单调的,可以用双指针解决,同时需要开一个数组存储计算结果,因为第k项和第k-1有关,但是k-1会比k先更新,导致无法计算出次优解.</p>
<p>例题:</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1858">P1858 多人背包</a></li>
</ul>
<h2 id="当背包容量物品体积过大时泛化物品">当背包容量/物品体积过大时/泛化物品</h2>
<p>这种题目往往会给数据一个特定的规律,那么突破点就在于数据的特殊性质上.</p>
<p>如P3188这种,因为体积过大,直接转移肯定是行不通的,类似于单调队列优化背包的思想,将他分层进行计算,但层于层之间有联系,那么要合并两层的数据....</p>
<p>合并的原理是什么?</p>
<p>我们将两个需要合并的层设为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>,要用给定的费用从这两个数组种得到最大的价值,如何求解呢?事实上,对于一个给定的费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，只需枚举将这个费用如何分配给两个层就可以了。那么就可以求得费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>在这两层中分配时取得的最大值,不断的枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>就会得到一个新的层,就完成了两个层的合并.这就是泛化思想在正整数域的体现.</p>
<p>关于泛化的概念可以去看背包九讲,下面引用一下.</p>
<p>参考背包九讲的说法:&quot;如果面对两个泛化物品<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，要用给定的费用从这两个泛化物品中得到最大的价值.怎么求呢？事实上，对于一个给定的费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0..</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">0..V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>的每一个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，可以求得费用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>分配到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>中的最大价值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。也即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>v</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>h</mi><mi>k</mi></msub><mo>+</mo><msub><mi>l</mi><mrow><mi>v</mi><mo>−</mo><mi>k</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(v)=max(h_k+l_{v-k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">0\leq k\leq v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>。可以看到，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>也是一个由泛化物品<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>决定的定义域为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>V</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,V]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">]</span></span></span></span>的函数，也就是说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>是一个由泛化物品<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>决定的泛化物品。&quot;</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3188">P3188 [HNOI2007]梦幻岛宝珠</a></li>
</ul>
<p>比较经典的题</p>
<h2 id="背包变形">背包变形</h2>
<p>背包并不是说一定用的上模板,我们可以利用背包的思想解决一些题目</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4026">P4026 [SHOI2008]循环的债务</a></li>
</ul>
<p>隐性背包,并没有直接背包の做法,而是采用了背包的思想,但是变成了枚举可行的初始容量,枚举物品个数然后转移.</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4303">P4303 [AHOI2006]基因匹配</a></li>
</ul>
<p>降维+数据结构维护前缀最大值即可,考虑背包思想,从后向前dp这样子就不会互相影响</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4823">P4823 [TJOI2013]拯救小矮人</a></li>
</ul>
<p>有时候题目给出的条件无法直接进行DP,但是数据范围又告诉我们没那么简单.可以多从转化问题入手,此题就是通过排序来处理出可行的DP顺序从而解决问题.</p>
<h2 id="背包计数方案数统计">背包计数/方案数统计</h2>
<p>既然是计数,那么必须做到不重不漏,高效全面</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4241">P4241 采摘毒瘤</a></li>
</ul>
<p>因为是计数,所以必须保证我们的统计不会<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">重</mi><mi mathvariant="normal">复</mi></mrow><annotation encoding="application/x-tex">重复</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">复</span></span></span></span>,那么考虑到在比当前物品大的物品<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>的基础上,不断加入当前物品,为了不重复,当前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>数组能够直接统计的情况只有比自己小的物品全选,因为我们知道正常情况下不会出现所有物品一起选择的方案,所以这种情况可以独立统计,但是在统计方案数的时候,不能将当前物品全部放入,因为更小的全部选上了,那么不能放入且能被确定的最小物品就是当前物品,如果最后一个物品也放进去的话,就会出现不知道谁被选作无法放入的最小物品,那么就无法确定统计的下届.那么是否这个物品没有被统计呢?这并不是,我们这里统计的仅仅是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">确</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">案</mi></mrow><annotation encoding="application/x-tex">可以确定的方案</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">案</span></span></span></span>,确定的是无法放入的是哪个物品,理所当然的应该从大到小统计,如果从小到大的话,会出现重复统计.完毕.</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4516">P4516 [JSOI2018]潜入行动</a></li>
</ul>
<p>比较套路的计数背包了,看到这种题肯定是大力设状态,大力转移就可以了,大力分类讨论.考虑到我们的转移式会提前更新一些dp值,所以另开一个数组用于暂存上一次dp的结果.</p>
<h2 id="树形背包">树形背包</h2>
<p>树形背包是在树形结构上按照一定的规则做的背包,往往需要和树的性质结合来解决问题.</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4037">P4037 [JSOI2008]魔兽地图</a></li>
</ul>
<p>比较令人烦躁的背包,子节点会对父节点产生影响,这就意味着我们在状态设计上需要考虑父节点,那么我们开一维用来储存供给给父节点合成的装备就可以了.</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4322">P4322 [JSOI2016]最佳团体</a></li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">0/1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span></span></span></span>分数规划+一般树形背包</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3780">P3780 [SDOI2017]苹果树</a></li>
</ul>
<p>非常有趣的背包难题,考虑到题目给的特殊条件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>−</mo><mi>h</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">t-h \leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,要取一条最长链免费拿,剩下的再树形DP,可是这两步是互相影响的,转化问题.将每个点拆成两个点,原来的节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>改成1,新增一个子节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_j=a_i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,那么这个免费链就一定在原来的树上,且不会影响正常的DP,但这条链将树分成了两部分,分别进行树形背包,单调队列优化即可做到O(nk)解决问题,大力卡常.</p>
<p>希望你能得到帮助<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>.</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Everything</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">is</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">permitted</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Miu_you の动态规划]]></title>
        <id>https://miuyou.github.io/post/miu_you-nodong-tai-gui-hua/</id>
        <link href="https://miuyou.github.io/post/miu_you-nodong-tai-gui-hua/">
        </link>
        <updated>2020-03-06T01:26:12.000Z</updated>
        <summary type="html"><![CDATA[<p>动态规划也炒鸡可爱的说!<br>
<img src="https://miuyou.github.io//post-images/1583457992014.jpg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>动态规划也炒鸡可爱的说!<br>
<img src="https://miuyou.github.io//post-images/1583457992014.jpg" alt="" loading="lazy"></p>
<!-- more -->
<p>欸,这篇废了,等所有子文章编辑完成了再来搞</p>
<h2 id="树形dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">树</mi><mi mathvariant="normal">形</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">树形DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">形</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1131">P1131 [ZJOI2007]时态同步</a><br>
简单树形DP,让所有点都和最慢得一样慢就可以了</li>
</ul>
<h2 id="杂类dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">杂</mi><mi mathvariant="normal">类</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">杂类DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">杂</span><span class="mord cjk_fallback">类</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1169">P1169 [ZJOI2007]棋盘制作</a><br>
悬线法</li>
<li><a href="https://www.luogu.com.cn/problem/P1437">P1437 [HNOI2004]敲砖块</a><br>
一般向DP</li>
<li><a href="https://www.luogu.com.cn/problem/P1841">P1841 [JSOI2007]重要的城市</a><br>
无可取代得最短路经过点为重要城市,也不知道和dp有什么关系</li>
<li><a href="https://www.luogu.com.cn/problem/P1772">P1772 [ZJOI2006]物流运输</a><br>
奇怪のDP,发现无法简单得跑一个分层图最短路,因为有着更改路径得操作,那么就要dp了,枚举是什么时候更改路径得</li>
</ul>
<h2 id="数学dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">学</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">数学DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">学</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1450">P1450 [HAOI2008]硬币购物</a><br>
是榕树,我死了,不合法方案为强制选<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+1个</li>
<li><a href="https://www.luogu.com.cn/problem/P2059">P2059 [JLOI2013]卡牌游戏</a><br>
窝又死了,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第i个人经过j-1轮会胜出,因为他的位置在不断变化,所以每次把庄家提到1的位置上,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">/</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">f_{i,j}+=f_{x,j-1}/m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault">m</span></span></span></span>,x为当前位置-新的庄家的位置</li>
<li><a href="https://www.luogu.com.cn/problem/P2473">P2473 [SCOI2008]奖励关</a><br>
考虑到正着dp甚至不知道要输出什么,考虑反过来,代码不用改多少就变成反着的啦,然后就加加加就行了,考虑到有可能当前集合已经选过当前礼品了,所以也可以取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mi mathvariant="normal">∣</mi><mo>(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>)</mo></mrow></msub><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">max{dp_{i+1,j|(...)},dp_{i+1,j}+a_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">∣</span><span class="mopen mtight">(</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>,因为题目说了&quot;假设你采取最优策略&quot;那么在能够选择拿或不拿的时候,自然拿走期望最高的啦</li>
</ul>
<h2 id="状态压缩dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">状</mi><mi mathvariant="normal">态</mi><mi mathvariant="normal">压</mi><mi mathvariant="normal">缩</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">状态压缩DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">压</span><span class="mord cjk_fallback">缩</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1896">P1896 [SCOI2005]互不侵犯</a><br>
简单的状态压缩</li>
</ul>
<h2 id="神仙dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">神</mi><mi mathvariant="normal">仙</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">神仙DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">神</span><span class="mord cjk_fallback">仙</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2051">P2051 [AHOI2009]中国象棋</a><br>
数据太大了,没法状态压缩,那么就dp喽,要详细的考虑到每种情况</li>
<li><a href="https://www.luogu.com.cn/problem/P4158">P4158 [SCOI2009]粉刷匠</a><br>
比较难想又比较难写的DP,其实熟练以后会觉得挺好写的.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Miu_you の 网络流]]></title>
        <id>https://miuyou.github.io/post/miu_you-no-wang-luo-liu/</id>
        <link href="https://miuyou.github.io/post/miu_you-no-wang-luo-liu/">
        </link>
        <updated>2020-03-04T04:01:12.000Z</updated>
        <summary type="html"><![CDATA[<p>这里就是放放可爱の网络流的题目和感想啦~~~~~~~<br>
<img src="https://miuyou.github.io//post-images/1583297071335.jpg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>这里就是放放可爱の网络流的题目和感想啦~~~~~~~<br>
<img src="https://miuyou.github.io//post-images/1583297071335.jpg" alt="" loading="lazy"></p>
<h2 id="-more-算法分析"><!-- more --><br>
算法分析</h2>
<p>开始了<br>
我这个萌新只会dinic,isap和上下界网络流先咕着<br>
这算法挺好懂得,<br>
考虑为什么最小割==最大流<br>
一个最小,一个最大,为什么会相等呢?<br>
因为既然割要让这个网络无法联通,也就不存在增广路了,最小得情况正好是最大流<br>
网络流主要考得是建模技巧,而不是算法本身,这也是为什么网络流得权重比较高得原因吧</p>
<h2 id="建模技巧">建模技巧</h2>
<p>1.大汇点大源点<br>
这个东西大家都会吧,可以简化题目,若有多个入点或者出点可以给他们连在一起</p>
<p>2.拆点<br>
如果对于点本身有限制,就应当拆点,例如要求路径不相交,可以在点本身连一条边,限制流量</p>
<p>3.求最小割<br>
最小割==最大流</p>
<p>技巧过多,下面一叠</p>
<h2 id="可爱の网络流们">可爱の网络流们</h2>
<h2 id="有趣の题">有趣の题</h2>
<ul>
<li>
<p><a href="https://www.luogu.com.cn/problem/P1251">P1251 餐巾计划问题</a><br>
有趣的题,依旧是比较难想.考虑每天要用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>块干净餐巾,为了满足要求,那么最大流一定是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum(a_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,同时这题有着许多限制果断拆点,分为白天和晚上,白天向ed连<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>做出边,但是为了获得旧餐巾从st连向夜晚一条<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,费用都为0,然后st向白天连一条,每个晚上能洗的方式都连一条到结束时的白天久做完啦!</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2055">P2055 [ZJOI2009]假期的宿舍</a><br>
因为要让所有人都有床睡,那么每个要床的连ed,每个有床的连st,如果认识就连一条边.</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2754">P2754 [CTSC1999]家园 / 星际转移问题</a><br>
因为这题实在难做,所以枚举时间加边,模拟每个车的运行,依次加边<br>
每个时间点像上一个时间点再连一次就可以了</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2764">P2764 最小路径覆盖问题</a><br>
还算不错的题目,考虑到不存在任何边的时候,总路径数为n,那么要求的就是合并掉的路径数量,因为一个点只能被另一个点合并,所以点的流量为1,那么最大流求出合并路径数tot,输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">n-tot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>即可</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2765">P2765 魔术球问题</a><br>
挨个加球,判断能和哪些球放一起,然后就连上去,如果这次加得球没有增加流量,代表放不了,则开一个新の柜子.</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2766">P2766 最长不下降子序列问题</a><br>
第一眼不可做,奇奇怪怪得题,第一问直接dp求解,然后凭借第一问的dp数组来建立图,让长度为len的点连向终点就可以保证第二问的条件,第三问直接额外加边就可以了.</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2774">P2774 方格取数问题</a><br>
因为要求最大的总权值,那么减去最小割就可以了</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P4009">P4009 汽车加油行驶问题</a><br>
将汽车以当前油量作为状态分层,然后跑spfa,欸,不是网络流</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P4016">P4016 负载平衡问题</a><br>
大于平均数作一堆,小于平均数作一堆,然后互相连,算出代价,跑一个最小割就可以了</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P3358">P3358 最长k可重区间集问题</a><br>
最长k可重代表着每个点的最大流量为k,那么考虑如何表达一个区间,例如从a到b的一个区间,可以写成从a直接流向b+1,如果选了这个区间,那么a到b的流量减一.</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P3357">P3357 最长k可重线段集问题</a><br>
和上一题差不多,考虑会有竖着的线段把他卡了</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P3356">P3356 火星探险问题 </a><br>
龟龟方案,无非是暴力连连连,但是输出方案比较有亮点</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P3980">P3980 [NOI2008]志愿者招募</a><br>
关于至少要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>流量的限制,可以让起点和终点的流量为inf,则需要限制的边改成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">inf-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>即可,为了满   足最大流的前提一定会流满</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2050">P2050 [NOI2012]美食节</a><br>
分批动态加边,需要了就加,不需要不加.</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2604">P2604 [ZJOI2010]网络扩容</a><br>
第一问正常求,考虑第二问,st和ed增加流量k,同时每对点加流量inf费用给的的边即可</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P3159">P3159 [CQOI2012]交换棋子</a><br>
看起来是一个板题,但是却加入了最多交换次数的限制,那么拆点,流量为k/2即可,如果他是起点不是终点(反之亦可),且k为奇数,那么再额外加入一点流量即可</p>
<h2 id="重复相似的练手题弱题">重复/相似的练手题/弱题</h2>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P3254">P3254 圆桌问题</a><br>
普通的最大流</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2153">P2153 [SDOI2009]晨跑</a><br>
普通的费用流</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2053">P2053 [SCOI2007]修车</a><br>
美食节的弱化题....</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2756">P2756 飞行员配对方案问题</a><br>
就是一个模板题</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2762">P2762 太空飞行计划问题</a><br>
拆点板题,读入弱智</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2763">P2763 试题库问题</a><br>
普通的模板题</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P2770">P2770 航空路线问题</a><br>
水题</p>
</li>
<li>
<p><a href="https://www.luogu.com.cn/problem/P3355">P3355 骑士共存问题</a><br>
求出最小割,解决了</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[                            省选补题计划]]></title>
        <id>https://miuyou.github.io/post/sheng-xuan-bu-ti-ji-hua-qwq/</id>
        <link href="https://miuyou.github.io/post/sheng-xuan-bu-ti-ji-hua-qwq/">
        </link>
        <updated>2020-03-01T09:27:41.000Z</updated>
        <summary type="html"><![CDATA[<p>因为窝太弱了,所以决定把省选题都刷了!<br>
<img src="https://miuyou.github.io//post-images/1583297086560.jpg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>因为窝太弱了,所以决定把省选题都刷了!<br>
<img src="https://miuyou.github.io//post-images/1583297086560.jpg" alt="" loading="lazy"></p>
<h2 id="-more-"><!-- more --></h2>
<h2 id="qwq">qwq</h2>
<h2 id="加油">加油!</h2>
<h2 id="哪怕稍微不那么弱也好啊qwq">哪怕稍微不那么弱也好啊qwq</h2>
<h2 id="下面就是写过的题啦qwq">下面就是写过的题啦qwq</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1110">P1110 [ZJOI2007]报表统计</a><br>
(完成)使用mulbiset过平衡树太棒啦(๑•̀ㅂ•́)و✧</li>
<li><a href="https://www.luogu.com.cn/problem/P1128">P1128 [HNOI2001]求正整数</a></li>
</ul>
<p>因为做过反素数,所以知道一个数字的因子个数该怎么算,而这题要求这个的逆运算,因为之前是搜索然后筛选,这次要逆向的话似乎也可以搜索,但数据范围不允许这种玄学算法通过,可以考虑dp,似乎是n方的,因为数字过大所以要转化转移方程,因为涉及到a的b次方,可以取对数优化</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1129">P1129 [ZJOI2007]矩阵游戏</a></li>
</ul>
<p>转换一下模型,可以发现是行对列匹配,转换成最大流解决</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1131">P1131 [ZJOI2007]时态同步</a><br>
简单的树形<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span></li>
<li><a href="https://www.luogu.com.cn/problem/P1169">P1169 [ZJOI2007]棋盘制作</a><br>
正方形悬线模板秒了,长方形要改一下,考虑从上向下转移,左右同时维护</li>
<li><a href="https://www.luogu.com.cn/problem/P1197">P1197 [JSOI2008]星球大战</a><br>
正难则反</li>
<li><a href="https://www.luogu.com.cn/problem/P1198">P1198 [JSOI2008]最大数</a><br>
动态开点线段树</li>
<li><a href="https://www.luogu.com.cn/problem/P1291">P1291 [SHOI2002]百事世界杯之旅</a><br>
概率期望入门</li>
</ul>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1295">P1295 [TJOI2011]书架</a><br>
非常有趣的单调队列+双端队列优化dp,论如何动态维护最大值,O(1)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1337">P1337 [JSOI2004]平衡点 / 吊打XXX</a><br>
模拟退火,自创多种随机化(单种过不了</li>
<li><a href="https://www.luogu.com.cn/problem/P1377">P1377 [TJOI2011]树的序</a><br>
欸,思维题</li>
<li><a href="https://www.luogu.com.cn/problem/P1418">P1418 [TJOI2011]构造矩阵</a><br>
网络流有趣的题目</li>
<li><a href="https://www.luogu.com.cn/problem/P1434">P1434 [SHOI2002]滑雪</a><br>
入门水题,注意边界</li>
<li><a href="https://www.luogu.com.cn/problem/P1437">P1437 [HNOI2004]敲砖块</a><br>
还不错的dp,写写写就对了,考虑合理运用边界来进行跳跃式转移</li>
<li><a href="https://www.luogu.com.cn/problem/P1446">P1446 [HNOI2008]Cards</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1450">P1450 [HAOI2008]硬币购物</a><br>
憨批榕树原理dp</li>
<li><a href="https://www.luogu.com.cn/problem/P1463">P1463 [POI2002][HAOI2007]反素数</a><br>
挺不错的搜索</li>
<li><a href="https://www.luogu.com.cn/problem/P1627">P1627 [CQOI2009]中位数</a><br>
弱智题,开个桶记录一下就好了</li>
<li><a href="https://www.luogu.com.cn/problem/P1640">P1640 [SCOI2010]连续攻击游戏</a><br>
比较有趣的并查集</li>
<li><a href="https://www.luogu.com.cn/problem/P1641">P1641 [SCOI2010]生成字符串</a><br>
组合计数基础</li>
<li><a href="https://www.luogu.com.cn/problem/P1772">P1772 [ZJOI2006]物流运输</a><br>
dp+最短路</li>
<li><a href="https://www.luogu.com.cn/problem/P1841">P1841 [JSOI2007]重要的城市</a><br>
dij做n遍,在最短路中若一条最短边是唯一的则起点为重要城市</li>
<li><a href="https://www.luogu.com.cn/problem/P1896">P1896 [SCOI2005]互不侵犯</a><br>
设dp状态为第i行放了第j种方式总共z个,谔谔</li>
<li><a href="https://www.luogu.com.cn/problem/P1972">P1972 [SDOI2009]HH的项链</a><br>
树状数组离线搞,主席树在线</li>
<li><a href="https://www.luogu.com.cn/problem/P2023">P2023 [AHOI2009]维护序列</a><br>
弱智低能题,就是一个模板(</li>
<li><a href="https://www.luogu.com.cn/problem/P2039">P2039 [AHOI2009]跳棋</a><br>
谔谔dp,谁知道讷</li>
</ul>
<ul>
<li>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2051">P2051 [AHOI2009]中国象棋</a><br>
神仙dp题</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2053">P2053 [SCOI2007]修车</a><br>
普通的费用流</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HEOI2016/TJOI2016]排序 题解]]></title>
        <id>https://miuyou.github.io/post/heoi2016tjoi2016pai-xu-ti-jie/</id>
        <link href="https://miuyou.github.io/post/heoi2016tjoi2016pai-xu-ti-jie/">
        </link>
        <updated>2020-02-27T06:50:33.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>题目要求我们求出第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>位置上的数字.<br>
暴力想法:暴力局域排序,每次排序的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span><br>
不合格,舍弃暴力,发现排序不可避免,那么考虑如何优化排序复杂度<br>
考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding="application/x-tex">01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span></span></span></span>串可以做到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span>排序(如何排序自行思考)<br>
那么考虑如何转换成一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01</mn></mrow><annotation encoding="application/x-tex">01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span></span></span></span>串<br>
约定比选择的数大的为1,小的为0<br>
但题目要求固定位置的数字,则选择的数不确定<br>
发现题目给出序列的为排列,则可二分所选择的数<br>
求出结果</p>
<p>logn排序的原理是<br>
因为序列全01,那么从小到大就是将所有的0放到前面,所有的1放到后面</p>
<p>时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define mid ((l+r)&gt;&gt;1)
#define ls (k&lt;&lt;1)
#define rs (k&lt;&lt;1|1)
#define lson ls,l,mid
#define rson rs,mid+1,r
int n,m,q,a[100050];
struct edge{
	int a,b,c;
}tu[100050];
struct node{
	int flag,sum;
}t[400050];
inline void pushdown(int k,int l,int r){
	if(t[k].flag==1){
		t[ls].flag=t[rs].flag=1;
		t[ls].sum=t[rs].sum=0;
	}else if(t[k].flag==2){
		t[ls].flag=t[rs].flag=2;
		t[ls].sum=(mid-l+1);t[rs].sum=(r-mid);
	}t[k].flag=0;
}
inline void built(int k,int l,int r,int x) {
	t[k].flag=0;
	if(l==r) {
		t[k].sum=(a[l]&gt;=x);
	} else {
		built(lson,x);
		built(rson,x);
        t[k].sum=t[ls].sum+t[rs].sum;
	}
}
inline int query(int k,int l,int r,int L,int R) {
	if(l&gt;r||r&lt;L||l&gt;R)return 0;
	if(L&lt;=l&amp;&amp;r&lt;=R)return t[k].sum;
    int tot=0;
	pushdown(k,l,r);
	if(L&lt;=mid)tot+=query(lson,L,R);
	if(mid&lt;R)tot+=query(rson,L,R);
	t[k].sum=t[ls].sum+t[rs].sum;
	return tot;
}
inline void gai(int k,int l,int r,int L,int R,int val){
	if(l&gt;r||r&lt;L||l&gt;R)return;
    if(L&lt;=l&amp;&amp;r&lt;=R){
        t[k].flag=val+1;
		t[k].sum=(r-l+1)*val;
    }else{
        pushdown(k,l,r);
		if(mid&gt;=L)gai(lson,L,R,val);
		if(mid&lt;R)gai(rson,L,R,val);
		t[k].sum=t[ls].sum+t[rs].sum;
    }
}
inline int cha(int k,int l,int r,int val){
	if(l&gt;r||r&lt;val||l&gt;val)return 0;
    if(l==val&amp;&amp;r==val){
        return t[k].sum;
    }else{
        pushdown(k,l,r);
		if(mid&gt;=val)return cha(lson,val);
		else return cha(rson,val);
    }
}
int check(int x){
	built(1,1,n,x);
	for(int i=1;i&lt;=m;++i){
        int val=query(1,1,n,tu[i].b,tu[i].c);
        if(!val)gai(1,1,n,tu[i].b,tu[i].c,0);
		if(tu[i].a){
			gai(1,1,n,tu[i].b,tu[i].b+val-1,1);
			gai(1,1,n,tu[i].b+val,tu[i].c,0);
		}else{
			val=(tu[i].c-tu[i].b+1)-val;
			gai(1,1,n,tu[i].b,tu[i].b+val-1,0);
			gai(1,1,n,tu[i].b+val,tu[i].c,1);
		}
	}
	return cha(1,1,n,q);
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1;i&lt;=m;++i){
		scanf(&quot;%d%d%d&quot;,&amp;tu[i].a,&amp;tu[i].b,&amp;tu[i].c);
	}int l=1,r=n,md,anse=0;cin&gt;&gt;q;
	while(l&lt;=r){
		md=(l+r)&gt;&gt;1;
		if(check(md)){
			anse=md;
			l=md+1;
		}else r=md-1;
	}cout&lt;&lt;anse&lt;&lt;endl;return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>