<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://miuyou.github.io/</id>
    <title>春待ち</title>
    <updated>2021-01-21T11:43:31.941Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://miuyou.github.io/"/>
    <link rel="self" href="https://miuyou.github.io/atom.xml"/>
    <subtitle>开端顺利 自这天起 离乡背井 等候春息  身处何地 等候春息</subtitle>
    <logo>https://miuyou.github.io/images/avatar.png</logo>
    <icon>https://miuyou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 春待ち</rights>
    <entry>
        <title type="html"><![CDATA[小东西]]></title>
        <id>https://miuyou.github.io/post/xiao-dong-xi/</id>
        <link href="https://miuyou.github.io/post/xiao-dong-xi/">
        </link>
        <updated>2021-01-21T11:42:58.000Z</updated>
        <content type="html"><![CDATA[<p>豹打龟速幂</p>
<pre><code class="language-cpp">long long mul(long long x,long long y,long long mod){
    x%=mod;y%=mod;
	return (x*y-(long long)((long double)x/mod*y)%mod*mod+mod)%mod;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4607 [SDOI2018]反回文串]]></title>
        <id>https://miuyou.github.io/post/p4607-sdoi2018fan-hui-wen-chuan/</id>
        <link href="https://miuyou.github.io/post/p4607-sdoi2018fan-hui-wen-chuan/">
        </link>
        <updated>2021-01-21T11:39:41.000Z</updated>
        <content type="html"><![CDATA[<p>好nb啊,,首先摸一摸不可以的情况,然后列个狮子出来,大概就是枚举循环节长度去计算,大力反演,反演出来的结果加以计算就行了</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>x</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><mi>F</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><munder><mo>∑</mo><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mfrac><mi>n</mi><mi>x</mi></mfrac></mrow></munder><mi>μ</mi><mo>(</mo><mi>k</mi><mo>)</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\sum_{x|n}F(x)g(x)\sum_{k|\frac{n}{x}}\mu(k)k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.6318099999999998em;vertical-align:-1.581805em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.581805em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">μ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<p>考虑一个 dp 的思想来统计答案，每次新增一个质因数  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 进入集合的时候，显然答案有两类，一类是不选入  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 一类是选入  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，选入  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">p
&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 的同时会使得所有贡献都乘以  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，令  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示之前的答案，则有  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>f</mi><mi>i</mi><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><mo>(</mo><msub><mi>f</mi><mi>i</mi></msub><mo>−</mo><msup><mi>p</mi><mo mathvariant="normal">′</mo></msup><msub><mi>f</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i&#x27;=(f_i-p&#x27;f_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，我们把每一项的贡献单独提取出来，则可以得到上式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><mi>μ</mi><mo>(</mo><mi>k</mi><mo>)</mo><mi>k</mi><mo>=</mo><mo>∏</mo><mo>(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum_{k|n}\mu(k)k=\prod(1-p_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">μ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∏</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;bitset&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define db double
#define ll long long
#define lb long double
#define be bitset
#define lll __int128
const int N=1e6+5;
const int INF=1e8+5;
const int M=1e5;
const ll mod=1e9+7;
inline void rd(ll &amp;x){
	x=0;
	char ch=getchar();bool flag=0;
	while((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-')ch=getchar();
	if(ch=='-')flag=1,ch=getchar();
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10ll+ch-'0',ch=getchar();
	if(flag)x=-x;return;
}
inline void rd(int &amp;x){
	x=0;
	char ch=getchar();bool flag=0;
	while((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-')ch=getchar();
	if(ch=='-')flag=1,ch=getchar();
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar();
	if(flag)x=-x;return;    
}
inline char rch() {
    char c; while ((c = getchar()) != 'N' &amp;&amp; c != 'E');
    return c;
}
inline ll gcd(ll a,ll b){
    return b?gcd(b,a%b):a;
}
ll n,k,p,q[N],lr;
long long mul(long long x,long long y,long long mod){
    x%=mod;y%=mod;
	return (x*y-(long long)((long double)x/mod*y)%mod*mod+mod)%mod;
}

inline ll ksm(ll x,ll y,ll p){
    ll ans=1ll;
    while(y){
        if(y&amp;1)ans=mul(ans,x,p);
        x=mul(x,x,p);
        y&gt;&gt;=1;
    }return ans;
}
inline ll F(ll x,ll y,ll p){
    return (mul(x,x,p)+y)%p;
}
ll prim[7]={2,325,9375,28178,450775,9780504,1795265022};
inline bool miller(ll x){
    if(x&lt;2)return 0;
    if(x==2||x==3)return 1;
    ll y=x-1,r=0;
    while(!(y&amp;1))++r,y&gt;&gt;=1;
    for(int i=0;i&lt;=6;++i){
        ll a=prim[i]%(x-2)+2;
        ll z=ksm(a,y,x);
        if(z==1||z==x-1)continue;
        for(int j=0;j&lt;r-1;++j){
            z=mul(z,z,x);
            if(z==x-1)break;
        }
        if(z!=x-1)return 0;
    }return 1;
}
inline ll rho(ll x){
    ll s=0,t=0,z=1ll*rand()%(x-1)+1,val=1;
    int num=0,goal=1;
    for(;;goal&lt;&lt;=1,s=t,val=1){
        for(num=1;num&lt;=goal;++num){
            t=F(t,z,x);
            val=mul(val,abs(t-s),x);
            if(num%127==0){
                ll k=gcd(val,x);
                if(k&gt;1)return k;
            }
        }
        ll k=gcd(val,x);
        if(k&gt;1)return k;
    }
}
inline void prollard(ll x){
    if(x&lt;2)return;
    if(miller(x)){
        q[++lr]=x;
    }else{
        ll y=x;
        while(y==x)y=rho(x);
        prollard(x/y);prollard(y);
    }
}
ll val[N],tot,num[N],ans,tat;
inline void dp(ll x,ll f, ll d){
    if(x==tot+1){
        if((d&amp;1)&amp;&amp;(!((n/d)&amp;1)))return;
        ll g=(d&amp;1)?d:d/2ll;
        ans=(ans+mul(mul(ksm(k,(d+1ll)/2ll,p),g,p),f,p))%p;
        if(ans&lt;0)ans+=p;
        ++tat;
        return;
    }
    ll h=1ll;
    for(int i=0;i&lt;=num[x];++i){
        if(i==num[x])dp(x+1,f,d*h);
        else dp(x+1,((f-mul(f,val[x],p))%p+p)%p,d*h);
        h=h*val[x];
    }
}
int main(){
    int t;
    rd(t);
    while(t--){
        lr=tot=0;ans=0;
        rd(n);rd(k);rd(p);
        prollard(n);
        sort(q+1,q+1+lr);
        for(int i=1;i&lt;=lr;++i){
            if(q[i]==q[i-1])++num[tot];
            else val[++tot]=q[i],num[tot]=1;
        }
        dp(1,1,1);
        printf(&quot;%lld\n&quot;,ans);
    }
    system(&quot;pause&quot;);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[CF786B Legacy]]]></title>
        <id>https://miuyou.github.io/post/cf786b-legacy/</id>
        <link href="https://miuyou.github.io/post/cf786b-legacy/">
        </link>
        <updated>2021-01-10T08:24:35.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/CF786B">CF786B Legacy</a></li>
</ul>
<p>线段树优化建图,因为生疏了所以头疼了会<br>
考虑点到区间就是正向连边<br>
区间到点就要反过来连边,那么再建一个倒着的树即可</p>
<pre><code class="language-cpp">inline void update(int op,int k,int l,int r,int L,int R,int w){
    if(L&lt;=l&amp;&amp;r&lt;=R){
        V[op].push_back((SpringWait){k,w});
    }else{
        int mid=(l+r)&gt;&gt;1;
        if(L&lt;=mid)update(op,k&lt;&lt;1,l,mid,L,R,w);
        if(mid&lt;R)update(op,k&lt;&lt;1|1,mid+1,r,L,R,w);
    }
}
inline void pdate(int op,int k,int l,int r,int L,int R,int w){
    if(L&lt;=l&amp;&amp;r&lt;=R){
        V[k+mn].push_back((SpringWait){op,w});
    }else{
        int mid=(l+r)&gt;&gt;1;
        if(L&lt;=mid)pdate(op,k&lt;&lt;1,l,mid,L,R,w);
        if(mid&lt;R)pdate(op,k&lt;&lt;1|1,mid+1,r,L,R,w);
    }
}
struct node{
    ll id,dis;
};
priority_queue&lt;node&gt;que;
inline bool operator &lt;(node x,node y){
    return x.dis&gt;y.dis;
};
ll dis[N];
inline void built(int k,int l,int r){
    if(l==r){
        tp[l]=k;
        V[k].push_back((SpringWait){k+mn,0});
        V[k+mn].push_back((SpringWait){k,0});
    }else{
        V[k].push_back((SpringWait){(k&lt;&lt;1),0});
        V[k].push_back((SpringWait){(k&lt;&lt;1)+1,0});
        V[(k&lt;&lt;1)+mn].push_back((SpringWait){k+mn,0});
        V[(k&lt;&lt;1)+1+mn].push_back((SpringWait){k+mn,0});
        int mid=(l+r)&gt;&gt;1;
        built(k&lt;&lt;1,l,mid);
        built(k&lt;&lt;1|1,mid+1,r);
    }
}
int main(){
    rd(n);rd(q);rd(s);mn=n*4;
    int opt,u,v,l,r,w;built(1,1,n);
    for(int i=1;i&lt;=q;++i){
        rd(opt);
        if(opt==1){
            rd(u);rd(v);rd(w);
            V[tp[u]].push_back((SpringWait){tp[v],w});
        }else if(opt==2){
            rd(u);rd(l);rd(r);rd(w);
            update(tp[u],1,1,n,l,r,w);
        }else{
            rd(u);rd(l);rd(r);rd(w);
            pdate(tp[u],1,1,n,l,r,w);
        }
    }
    
    que.push((node){tp[s],0});

    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[CF600E][启发式合并]]]></title>
        <id>https://miuyou.github.io/post/cf600eqi-fa-shi-he-bing/</id>
        <link href="https://miuyou.github.io/post/cf600eqi-fa-shi-he-bing/">
        </link>
        <updated>2021-01-09T07:44:58.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/CF600E">CF600E Lomsat gelral</a></li>
</ul>
<p>我是弟弟<br>
这都写错</p>
<pre><code class="language-cpp">
inline void work(int x,int fa,int z){
   // cout&lt;&lt;x&lt;&lt;&quot;  &quot;&lt;&lt;fa&lt;&lt;endl;
    ++sum[a[x]];
    if(sum[a[x]]&gt;top){
        num=0;
        top=sum[a[x]];
        num=a[x];
    }else if(sum[a[x]]==top){
        num+=a[x];
    }
    for(int i=firs[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa||y==z)continue;
        work(y,x,z);
    }
}
inline void init(int x,int fa){
    --sum[a[x]];
    for(int i=firs[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa)continue;
        init(y,x);
    }
}
inline void dfs(int x,int fa){
    for(int i=firs[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa||y==son[x])continue;
        dfs(y,x);
        init(y,x);
        num=top=0;
    }
    if(son[x]){
        dfs(son[x],x);
    }
    work(x,fa,son[x]);
    ans[x]=num;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[SDOI2011导弹拦截][CDQ][DP]]]></title>
        <id>https://miuyou.github.io/post/sdoi2011-dao-dan-lan-jie-cdqdp/</id>
        <link href="https://miuyou.github.io/post/sdoi2011-dao-dan-lan-jie-cdqdp/">
        </link>
        <updated>2021-01-01T04:18:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2487">P2487 [SDOI2011]拦截导弹</a><br>
拦了半天发现是自己人内鬼了<br>
首先一眼看出是CDQ,然后要求一个中间点的方案需要他往前和他往后,所以要倒过来再做一次CDQ</li>
</ul>
<pre><code class="language-cpp">int n;
struct SpringWait
{
	int a,b,f,id;
	db g;
}f[N],g[N];
inline bool cmp1(SpringWait X,SpringWait Y){
	return X.b&lt;Y.b;
}
inline bool cmp2(SpringWait X,SpringWait Y){
	return X.id&gt;Y.id;
}
inline bool cmp3(SpringWait X,SpringWait Y){
	return X.a&lt;Y.a;
}
inline bool cmp4(SpringWait X,SpringWait Y){
	return X.b&gt;Y.b;
}
inline bool cmp5(SpringWait X,SpringWait Y){
	return X.id&lt;Y.id;
}
inline bool cmp6(SpringWait X,SpringWait Y){
	return X.a&gt;Y.a;
}
int rk[N];
int tf[N];
db tg[N];
inline int lowbit(int x){
	return x&amp;(-x);
}
inline void insert(int x,int ff,db gg){
	while(x&lt;=n){
		if(tf[x]==ff){
			tg[x]+=gg;
		}else if(tf[x]&lt;ff){
			tg[x]=gg;
			tf[x]=ff;
		}
		x+=lowbit(x);
	}
}
inline void del(int x){
	while(x&lt;=n){
		tf[x]=0;
		tg[x]=0;
		x+=lowbit(x);
	}
}
inline void query(int x,int &amp;l,db &amp;r){
	while(x){
		if(l==tf[x]){
			r+=tg[x];
		}else if(l&lt;tf[x]){
			l=tf[x];
			r=tg[x];
		}
		x-=lowbit(x);
	}
}
inline void CDQ(int l,int r){
	if(l==r)return;
	int mid=(l+r)&gt;&gt;1;
	CDQ(l,mid);
	sort(f+1+mid,f+r+1,cmp3);
	int L=l;
	for(int R=mid+1;R&lt;=r;++R){
		while(f[L].a&lt;=f[R].a&amp;&amp;L&lt;=mid){
			insert(f[L].b,f[L].f,f[L].g);
			++L;
		}
		int ff=0;db gg=0;
		query(f[R].b,ff,gg);
		if(f[R].f&lt;ff+1){
			f[R].f=ff+1;
			f[R].g=gg;
		}else if(f[R].f==ff+1){
			f[R].g+=gg;
		}
	}
	for(int i=l;i&lt;=mid;++i)del(f[i].b);
	sort(f+mid+1,f+1+r,cmp2);
	CDQ(mid+1,r);
	sort(f+l,f+1+r,cmp3);
}
inline void CD(int l,int r){
	if(l==r)return;
	int mid=(l+r)&gt;&gt;1;
	CD(l,mid);
	sort(g+1+mid,g+r+1,cmp6);
	int L=l;
	for(int R=mid+1;R&lt;=r;++R){
		while(g[L].a&gt;=g[R].a&amp;&amp;L&lt;=mid){
			insert(g[L].b,g[L].f,g[L].g);
			++L;
		}
		int ff=0;db gg=0;
		query(g[R].b,ff,gg);
		if(g[R].f&lt;ff+1){
			g[R].f=ff+1;
			g[R].g=gg;
		}else if(g[R].f==ff+1){
			g[R].g+=gg;
		}
	}
	for(int i=l;i&lt;=mid;++i)del(g[i].b);
	sort(g+mid+1,g+1+r,cmp5);
	CD(mid+1,r);
	sort(g+l,g+1+r,cmp6);
}
int main(){
	rd(n);
	for(int i=1;i&lt;=n;++i){
		rd(f[i].a);rd(f[i].b);f[i].id=i;f[i].f=1;
		f[i].g=1.0;
		g[i]=f[i];
	}
	sort(f+1,f+1+n,cmp1);
	rk[1]=1;int tot=1;
	for(int i=2;i&lt;=n;++i){
		if(f[i].b==f[i-1].b){
			rk[i]=tot;
		}else {
			++tot;
			rk[i]=tot;
		}
	}
	for(int i=1;i&lt;=n;++i){
		f[i].b=rk[i];
	}sort(f+1,f+1+n,cmp2);
	CDQ(1,n);

	/*for(int i=1;i&lt;=n;++i){
		printf(&quot;%d %d %d %d %.5lf\n&quot;,f[i].a,f[i].b,f[i].id,f[i].f,f[i].g);
	}*/
	sort(g+1,g+1+n,cmp4);
	rk[1]=1;tot=1;
	for(int i=2;i&lt;=n;++i){
		if(g[i].b==g[i-1].b){
			rk[i]=tot;
		}else {
			++tot;
			rk[i]=tot;
		}
	}
	for(int i=1;i&lt;=n;++i){
		g[i].b=rk[i];
	}sort(g+1,g+1+n,cmp5);
	CD(1,n);
	/*for(int i=1;i&lt;=n;++i){
		printf(&quot;%d %d %d %d %.5lf\n&quot;,g[i].a,g[i].b,g[i].id,g[i].f,g[i].g);
	}*/
	sort(f+1,f+1+n,cmp5);
	sort(g+1,g+1+n,cmp5);
	int len=0;
	for(int i=1;i&lt;=n;++i){
		len=max(len,f[i].f);
	}
	cout&lt;&lt;len&lt;&lt;endl;
	db ans=0;
	for(int i=1;i&lt;=n;++i){
		if(f[i].f==len)ans+=f[i].g;
	}
	for(int i=1;i&lt;=n;++i){
		if(f[i].f+g[i].f-1==len){
			printf(&quot;%.5lf &quot;,(f[i].g*g[i].g)/ans);
		}else{
			printf(&quot;0.00000 &quot;);
		}
	}
	system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[SDOI2007游戏][字符串][HASH]]]></title>
        <id>https://miuyou.github.io/post/sdoi2007-you-xi-zi-fu-chuan-hash/</id>
        <link href="https://miuyou.github.io/post/sdoi2007-you-xi-zi-fu-chuan-hash/">
        </link>
        <updated>2020-12-29T08:21:05.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2462">P2462 [SDOI2007]游戏</a></li>
</ul>
<p>简单题,要咋做就咋做就行了,给他hash一下分层DP</p>
<pre><code class="language-cpp">
n=1;
	while(~scanf(&quot;%s&quot;,ss+1)){
		
		a[n].len=strlen(ss+1);
		for(int i=1;i&lt;=a[n].len;++i)a[n].s[i]=ss[i];
		++n;
	}--n;
	sort(a+1,a+1+n);
	int len=a[1].len;
	pw[0]=1ll;
	for(int i=1;i&lt;=100;++i)pw[i]=pw[i-1]*base%mod;
	int tp=1;
	for(int i=1;i&lt;=n&amp;&amp;a[i].len==len;++i){
		f[i]=1;
		insert(i);++tp;
	}
	if(tp==n+1){
		cout&lt;&lt;1&lt;&lt;endl;
		cout&lt;&lt;a[1].s&lt;&lt;endl;
	}else{
		for(int i=tp;i&lt;=n;i=tp){
			for(tp=i;tp&lt;=n&amp;&amp;a[tp].len==a[i].len;++tp){
				int x=get(tp);
				int y=x;
				f[tp]=1;
				for(int j=1;j&lt;=a[tp].len;++j){
					x=((y-pw[a[tp].s[j]-'a'])%mod+mod)%mod;
					if(g[x]){
						if(ha[x]+1&gt;f[tp]){
							f[tp]=ha[x]+1;
							nex[tp]=g[x];
						}
					}
				}
			}memset(ha,0,sizeof(ha));memset(g,0,sizeof(g));
			for(int j=i;j&lt;tp;++j){
				insert(j);
			} 
		}
		int pt=1;
		for(int i=1;i&lt;=n;++i){
			if(f[i]&gt;f[pt]){
				pt=i;
			}
		}
		cout&lt;&lt;f[pt]&lt;&lt;endl;
		dfs(pt);
	}	

    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[yyy's love IV][线段树DP]]]></title>
        <id>https://miuyou.github.io/post/yyys-love-ivxian-duan-shu-dp/</id>
        <link href="https://miuyou.github.io/post/yyys-love-ivxian-duan-shu-dp/">
        </link>
        <updated>2020-12-27T15:45:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2418">P2418 yyy loves OI IV</a></li>
</ul>
<p>我光想想就硬了(指拳头)</p>
<p>很容易想,需要处理的是快速查询可行区间最小值,使用线段树即可,至于臭味相投的人那就另外整点东西处理下就行了</p>
<p>注意:线段树是建立在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>轴上的,包括负区间....</p>
<pre><code class="language-cpp">int x[N],y[N],X[N],Y[N],g[N];
int main(){
	rd(n);rd(m);
	for(int i=1;i&lt;=n;++i){
		rd(a[i]);
		if(a[i]==1)a[i]=-1;
		else a[i]=1;
		x[i]=x[i-1]+(a[i]==-1);
		y[i]=y[i-1]+(a[i]==1);
	}
	memset(t,0x3f,sizeof(t));
	memset(g,0x3f,sizeof(g));
	memset(X,0x3f,sizeof(X));
	memset(Y,0x3f,sizeof(Y));
	update(1,-M,M,0,0);
	X[0]=Y[0]=g[M]=0;
	int opt,num;
	opt=0;num=0;
	f[0]=0;
	for(int i=1;i&lt;=n;++i){
		sum[i]=sum[i-1]+a[i];
		f[i]=query(1,-M,M,max(sum[i]-m,-M),min(M,sum[i]+m))+1;
		f[i]=min(f[i],f[i-1]+1);
		f[i]=min(f[i],X[x[i]]+1);
		f[i]=min(f[i],Y[y[i]]+1);
		X[x[i]]=min(f[i],X[x[i]]);
		Y[y[i]]=min(f[i],Y[y[i]]);
		update(1,-M,M,sum[i],f[i]);
	}
	cout&lt;&lt;f[n]&lt;&lt;endl;
	system(&quot;Pause&quot;);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2006字符串拼接][字符串][BFS][AC自动机]]]></title>
        <id>https://miuyou.github.io/post/hnoi2006-zi-fu-chuan-pin-jie-zi-fu-chuan-bfsac-zi-dong-ji/</id>
        <link href="https://miuyou.github.io/post/hnoi2006-zi-fu-chuan-pin-jie-zi-fu-chuan-bfsac-zi-dong-ji/">
        </link>
        <updated>2020-12-26T15:15:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2322">P2322 [HNOI2006]最短母串问题</a></li>
</ul>
<p>首先建个自动机出来,同时处理一下每个叶子结点有哪些节点<br>
然后就是直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">BFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>,性质自然</p>
<pre><code class="language-cpp">short n,cnt,ch[N][26];
char s[N];
int date[N];
inline void ins(int zi){
	int len=strlen(s),now=1;
	for(int i=0;i&lt;len;++i){
		int x=s[i]-'A';
		if(!ch[now][x]){
			ch[now][x]=++cnt;
		}now=ch[now][x];
	}
	date[now]|=(1&lt;&lt;zi);
	//cout&lt;&lt;now&lt;&lt;endl;
}
short q[N],l,r,fail[N];
void FA(){
	r=-1;
	for(int i=0;i&lt;=25;++i)ch[0][i]=1;
	q[++r]=1;
	while(l&lt;=r){
		int x=q[l];++l;
		for(int i=0;i&lt;=25;++i){
			if(ch[x][i]){
				fail[ch[x][i]]=ch[fail[x]][i];
				date[ch[x][i]]|=date[ch[fail[x]][i]];
				q[++r]=ch[x][i];
			}else{
				ch[x][i]=ch[fail[x]][i];
			}
		}
	}
}

queue&lt;int&gt;now,son;
bool vis[N][M];
char ans[N*M];
int nex[N*M];
int main(){
	cin&gt;&gt;n;cnt=1;
	for(int i=0;i&lt;n;++i){
		scanf(&quot;%s&quot;,s);
		ins(i);
	}
	FA();
	now.push(1);
	son.push(0);
	int num=0,sum=0;
	vis[0][0]=1;
	while(now.size()){
		int xnow=now.front();
		int xson=son.front();
		now.pop();
		son.pop();
		if(xson==((1&lt;&lt;n)-1)){
			int le=0;
			while(num){
				s[++le]=ans[num];
				num=nex[num];
			}
			while(le)putchar(s[le--]);
			break;
		}
		for(int i=0;i&lt;=25;++i){
			if(!vis[ch[xnow][i]][xson|date[ch[xnow][i]]]){
				vis[ch[xnow][i]][xson|date[ch[xnow][i]]]=1;
				now.push(ch[xnow][i]);
				son.push(xson|date[ch[xnow][i]]);
				nex[++sum]=num;
				ans[sum]='A'+i;
			}
		}
		++num;
	}
	system(&quot;Pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2005星际贸易][动态规划][单调队列优化][背包路径]]]></title>
        <id>https://miuyou.github.io/post/hnoi2005-xing-ji-mao-yi-dong-tai-gui-hua-dan-diao-dui-lie-you-hua-bei-bao-lu-jing/</id>
        <link href="https://miuyou.github.io/post/hnoi2005-xing-ji-mao-yi-dong-tai-gui-hua-dan-diao-dui-lie-you-hua-bei-bao-lu-jing/">
        </link>
        <updated>2020-12-26T15:09:00.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2317">P2317 [HNOI2005]星际贸易</a></li>
</ul>
<p>首先背包求出第一问,并且得到所有强制要选的点</p>
<p>那么接下来就是要最下化满足要求的路径花费</p>
<p>发现转移就俩种,要么从某个点飞过来要么原地加油,枚举某个点以及油量,复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,用单调队列搞搞就能优化成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>然鹅这题在背包部分翻车了....不该省的不要省,多重背包做不到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>的空间复杂度的</p>
<pre><code class="language-cpp">
 rd(n);rd(m);rd(RR);rd(LL);
    RR=min(RR,2*n);
    for(int i=1;i&lt;=n;++i){
        rd(a[i]);rd(b[i]);rd(l[i]);rd(p[i]);rd(f[i]);
    }
    for(int i=1;i&lt;=n;++i){
        if(l[i]-l[i-1]&gt;LL){
            puts(&quot;Poor Coke!&quot;);return 0;
        }
    }
    memset(bb,-1,sizeof(bb));
    bb[0][0]=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=0;j&lt;=m;++j){
            if(bb[i-1][j]&gt;=0)bb[i][j]=bb[i-1][j];
            if(j&gt;=a[i]&amp;&amp;bb[i-1][j-a[i]]&gt;=0){
                bb[i][j]=max(bb[i][j],bb[i-1][j-a[i]]+b[i]);
            }
        }
    }
    int an=0;int tp=0;
    for(int i=0;i&lt;=m;++i)if(bb[n][i]&gt;bb[n][an])an=i;
    for(int i=n,j=an;i;--i){
        if(bb[i][j]==bb[i-1][j])continue;
        else vis[i]=1,j-=a[i];
    }an=bb[n][an];
    
    memset(dp,0x3f,sizeof(dp));
    for(int i=0;i&lt;=RR;++i)L[i]=1;
    dp[0][RR]=0;
    q[RR][++R[RR]]=0;
    vis[n]=1;
    for(int i=1;i&lt;=n;++i){
        for(int j=0;j&lt;=RR;++j){
            if(p[i]&gt;0&amp;&amp;j&gt;0)dp[i][j]=min(dp[i][j],dp[i][j-1]+p[i]);
          
            if(L[j+2]&lt;=R[j+2])
            dp[i][j]=min(dp[i][j],dp[q[j+2][L[j+2]]][j+2]+f[i]);
            if(vis[i])L[j]=1,R[j]=0;
            while(L[j]&lt;=R[j]&amp;&amp;(dp[q[j][R[j]]][j]&gt;=dp[i][j]))--R[j];
            q[j][++R[j]]=i;
              while (L[j]&lt;=R[j]&amp;&amp;(l[i+1]-l[q[j][L[j]]]&gt;LL))++L[j];
        }
    }
    int ans=0;
    for(int i=0;i&lt;=RR;++i){if(dp[n][i]&lt;dp[n][ans])ans=i;//cout&lt;&lt;dp[n][i]&lt;&lt;endl;
    };
    if(dp[n][ans]==dp[0][0])puts(&quot;Poor Coke!&quot;);
    else printf(&quot;%d %d&quot;,an,an-dp[n][ans]);


    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[逛庙会][动态规划][状态压缩]]]></title>
        <id>https://miuyou.github.io/post/guang-miao-hui-dong-tai-gui-hua-zhuang-tai-ya-suo/</id>
        <link href="https://miuyou.github.io/post/guang-miao-hui-dong-tai-gui-hua-zhuang-tai-ya-suo/">
        </link>
        <updated>2020-12-25T14:06:44.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2238">P2238 逛庙会</a></li>
</ul>
<p>还算不错的题.....考虑俩种转移方式产生的不确定因素,将其状态压缩然后转移</p>
<pre><code class="language-cpp">
  for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]+1);
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            if(s[i][j]=='.'){
                a[i][j]=0;
            }else{
                a[i][j]=s[i][j]-'0';
            }
        }
    }
    int mn=15;
    memset(b,0x3f,sizeof(b));
    b[1][1][mn]=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            for(int x=0;x&lt;=mn;++x){
                for(int y=0;y&lt;=mn;++y){
                    if((((x&amp;4)==0)!=((y&amp;8)==0))||(!(x&amp;1))||(((x&amp;2)!=0)+((y&amp;1)!=0)+((y&amp;4)!=0)&lt;=1))continue;
                    int ans=b[i][j][x];
                    if(y&amp;4)ans+=a[i+1][j+1];
                    if(y&amp;2)ans+=a[i-1][j+2];
                    if(y&amp;1)ans+=a[i][j+2];
                    b[i][j+1][y]=min(b[i][j+1][y],ans);
                }
                for(int y=0;y&lt;=mn;++y){
                     if((((x&amp;1)==0)!=((y&amp;2)==0))||(!(x&amp;4))||(((x&amp;8)!=0)+((y&amp;1)!=0)+((y&amp;4)!=0)&lt;=1))continue;
                    int ans=b[i][j][x];
                    if(y&amp;1)ans+=a[i+1][j+1];
                    if(y&amp;4)ans+=a[i+2][j];
                    if(y&amp;8)ans+=a[i+2][j-1];
                    b[i+1][j][y]=min(b[i+1][j][y],ans);
                }
            }
        }
    }
    cout&lt;&lt;b[n][m][15]&lt;&lt;endl;

    ```</code></pre>
]]></content>
    </entry>
</feed>