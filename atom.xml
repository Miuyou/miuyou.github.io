<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://miuyou.github.io/</id>
    <title>春待ち</title>
    <updated>2020-12-23T16:13:31.838Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://miuyou.github.io/"/>
    <link rel="self" href="https://miuyou.github.io/atom.xml"/>
    <subtitle>开端顺利 自这天起 离乡背井 等候春息  身处何地 等候春息</subtitle>
    <logo>https://miuyou.github.io/images/avatar.png</logo>
    <icon>https://miuyou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 春待ち</rights>
    <entry>
        <title type="html"><![CDATA[[排队打饭][动态规划][不错的状态压缩]]]></title>
        <id>https://miuyou.github.io/post/pai-dui-da-fan-dong-tai-gui-hua-bu-cuo-de-zhuang-tai-ya-suo/</id>
        <link href="https://miuyou.github.io/post/pai-dui-da-fan-dong-tai-gui-hua-bu-cuo-de-zhuang-tai-ya-suo/">
        </link>
        <updated>2020-12-23T16:09:04.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2157">P2157 [SDOI2009]学校食堂</a></li>
</ul>
<p>刚看到题目会觉得难以下手</p>
<p>考虑最难解决的是如何维护那些人吃过饭了那些人可以吃饭,发现大家的容忍度都不高,将其状态压缩,那么就可以传递那些人吃过了,然后考虑上一个是谁吃会影响到计算结果,那么再开一维记录上一个是谁,就可以转移啦.想当于每个点都要背包一下怎么选后面谁吃,然后转移到下一个人的前提是这个人吃过了.</p>
<pre><code class="language-cpp">
memset(f,0x3f,sizeof(f));
		f[1][0][7]=0;
		for(int i=1;i&lt;=n;++i){
			for(int j=0;j&lt;MAXN;++j){
				for(int k=-8;k&lt;=7;++k){
					if(f[i][j][k+8]!=f[0][0][0]){
						if(j&amp;1){
							f[i+1][j&gt;&gt;1][k+7]=min(f[i+1][j&gt;&gt;1][k+7],f[i][j][k+8]);
						}else{
							int r=f[0][0][0];
							for(int z=0;z&lt;=7;++z){
								if(j&amp;(1&lt;&lt;z))continue;
								if(i+z&gt;r)break;
								r=min(r,i+z+b[i+z]);
								f[i][j|(1&lt;&lt;z)][z+8]=min(f[i][j|(1&lt;&lt;z)][z+8],f[i][j][k+8]+((i+k)?(a[i+k]^a[i+z]):0));

							}
						}
					}
				}
			}
		}
		int ans=f[0][0][0];
		for(int i=0;i&lt;=8;++i){
			ans=min(ans,f[n+1][0][i]);
		//	cout&lt;&lt;f[n+1][0][i]&lt;&lt;endl;
		}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringWait's 置换]]></title>
        <id>https://miuyou.github.io/post/springwaits-zhi-huan/</id>
        <link href="https://miuyou.github.io/post/springwaits-zhi-huan/">
        </link>
        <updated>2020-12-22T17:11:39.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>u</mi><mi>r</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Burnside</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span> 引理： 对于一个置换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>，若一个着色方案<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 经过置换后不变，则称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的不动点。记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的不动点数目为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>，则等价类个数为所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> 的平均值。</p>
<p>例题- <a href="https://www.luogu.com.cn/problem/P1446">P1446 [HNOI2008]Cards</a></p>
<pre><code class="language-cpp">
ll n,r,b,g,m,p,a[M],f[N][N][N];
bool vis[M];
ll t[M],sum,siz[M];
inline ll work(){
	memset(vis,0,sizeof(vis));
	memset(f,0,sizeof(f));
	f[0][0][0]=1;sum=0;
	memset(siz,0,sizeof(siz));
	for(int i=1;i&lt;=n;++i){
		if(vis[i])continue;
		int x=i;
		++sum;
		while(!vis[x]){
			vis[x]=1;
			x=a[x];
			++siz[sum];
		}
	}
	for(int z=1;z&lt;=sum;++z){
		for(int i=r;~i;--i){
			for(int j=b;~j;--j){
				for(int k=g;~k;--k){
					if(i&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i-siz[z]][j][k])%p;
					if(j&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i][j-siz[z]][k])%p;
					if(k&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i][j][k-siz[z]])%p;
				}
			}
		}
	}
	return f[r][b][g];
}
inline ll ksm(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&amp;1)ans=1ll*ans*x%p;
		x=1ll*x*x%p;
		y&gt;&gt;=1;
	}return ans;
}
int main(){
	rd(r);rd(b);rd(g);rd(m);rd(p);
	n=r+b+g;
	int ans=0;
	for(int i=1;i&lt;=m;++i){
		for(int j=1;j&lt;=n;++j){
			rd(a[j]);
		}
		ans=(ans+work())%p;
	}
	for(int i=1;i&lt;=n;++i)a[i]=i;
	ans=(ans+work())%p;
	ans=1ll*ans*ksm(m+1,p-2)%p;
	cout&lt;&lt;ans&lt;&lt;endl;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[铁马落地][动态规划][线段树优化DP]]]></title>
        <id>https://miuyou.github.io/post/tie-ma-luo-di-dong-tai-gui-hua-xian-duan-shu-you-hua-dp/</id>
        <link href="https://miuyou.github.io/post/tie-ma-luo-di-dong-tai-gui-hua-xian-duan-shu-you-hua-dp/">
        </link>
        <updated>2020-12-22T16:53:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1442">P1442 铁球落地</a></li>
</ul>
<p>先弄一个假假的想法,发现影响复杂的是快速找到下一层,那么从下往上线段树区间覆盖就好了....</p>
<pre><code class="language-cpp">
struct SpringWait{
	int h,l,r;
}a[N];
inline bool operator &lt;(SpringWait a,SpringWait b){
	return a.h&lt;b.h;
}
int t[N],num;
int f[N],g[N],ls[N],rs[N],flag[N&lt;&lt;2];
inline void pushdown(int k){
	if(flag[k]){
		flag[k&lt;&lt;1]=flag[k];
		flag[k&lt;&lt;1|1]=flag[k];
		flag[k]=0;
	}
}
inline int query(int k,int l,int r,int x){
	if(l==r)return flag[k];
	pushdown(k);
	int mid=(l+r)&gt;&gt;1;
	if(x&lt;=mid)return query(k&lt;&lt;1,l,mid,x);
	else return query(k&lt;&lt;1|1,mid+1,r,x);
}
inline void update(int k,int l,int r,int L,int R,int x){
	if(L&lt;=l&amp;&amp;r&lt;=R){
		flag[k]=x;
	}else{
		int mid=(l+r)&gt;&gt;1;
		if(L&lt;=mid)update(k&lt;&lt;1,l,mid,L,R,x);
		if(R&gt;mid)update(k&lt;&lt;1|1,mid+1,r,L,R,x);
	}
}
int main(){
	rd(n);rd(h);
	int x,y;
	rd(x);rd(y);
	for(int i=1;i&lt;=n;++i){
		rd(a[i].h);rd(a[i].l);rd(a[i].r);
		t[++num]=a[i].l;
		t[++num]=a[i].r;
	}
	++n;
	a[n].l=a[n].r=x;
	a[n].h=y;
	t[++num]=x;
	sort(a+1,a+1+n);
	sort(t+1,t+1+num);
	//num=unique(t+1,t+1+num)-t-1;
	for(int i=1;i&lt;=n;++i){
		a[i].l=lower_bound(t+1,t+1+num,a[i].l)-t;
		a[i].r=lower_bound(t+1,t+1+num,a[i].r)-t;
	}
	for(int i=1;i&lt;=n;++i){
		ls[i]=query(1,1,num,a[i].l);
		rs[i]=query(1,1,num,a[i].r);
		update(1,1,num,a[i].l,a[i].r,i);
	}
	memset(f,0x3f,sizeof(f));
	memset(g,0x3f,sizeof(g));
	f[0]=g[0]=0;
	for(int i=1;i&lt;=n;++i){
		if(a[i].h-a[ls[i]].h&lt;=h){
			if(ls[i]){
				f[i]=min(f[i],f[ls[i]]+t[a[i].l]-t[a[ls[i]].l]+a[i].h-a[ls[i]].h);
				f[i]=min(f[i],g[ls[i]]-t[a[i].l]+t[a[ls[i]].r]+a[i].h-a[ls[i]].h);
			}else{
				f[i]=a[i].h;
			}
		}

		if(a[i].h-a[rs[i]].h&lt;=h){
			if(rs[i]){
				g[i]=min(g[i],f[rs[i]]+t[a[i].r]-t[a[rs[i]].l]+a[i].h-a[rs[i]].h);
				g[i]=min(g[i],g[rs[i]]-t[a[i].r]+t[a[rs[i]].r]+a[i].h-a[rs[i]].h);
			}else{
				g[i]=a[i].h;
			}
		}
	}
	printf(&quot;%d\n&quot;,min(f[n],g[n]));
	system(&quot;Pause&quot;);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2003历史年份][动态规划][线段树优化建图]]]></title>
        <id>https://miuyou.github.io/post/hnoi2003-li-shi-nian-fen-dong-tai-gui-hua-xian-duan-shu-you-hua-jian-tu/</id>
        <link href="https://miuyou.github.io/post/hnoi2003-li-shi-nian-fen-dong-tai-gui-hua-xian-duan-shu-you-hua-jian-tu/">
        </link>
        <updated>2020-12-22T08:34:28.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2282">P2282 [HNOI2003]历史年份</a></li>
</ul>
<p>orzzzzzzzzzzzzzzzzzzz</p>
<p>调了一天</p>
<p>让我们先把弱化版给切掉</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1415">P1415 拆分数列</a></li>
</ul>
<p>一路填表过去就好了,正着一次反着一次<br>
先求出最小后缀,发现对于每个值的左下标越靠近n越小<br>
然后倒着做回来,右下标越靠近n越nb</p>
<p>那么</p>
<pre><code class="language-cpp">

inline bool cmp(int l1,int r1,int l2,int r2){
	int len1=r1-l1+1;
	int len2=r2-l2+1;
	int s1=l1,s2=l2,e1=r1,e2=r2;
	while(!a[s1]){
		++s1;
		--len1;
	}
	while (!a[s2]){
		++s2;
		--len2;
	}
	if(len1&gt;len2)return 0;
	if(len1&lt;len2)return 1;
	for(int i=0;i&lt;len1;++i){
		if(a[s1+i]!=a[s2+i]){
			return 	a[s1+i]&lt;a[s2+i];
		}	
	}
	return 0;
}
int main(){
	scanf(&quot;%s&quot;,s+1);
	n=strlen(s+1);
	for(int i=1;i&lt;=n;++i){
		a[i]=s[i]-'0';
	}
	f[1]=1;
	for(int i=2;i&lt;=n;++i){
		for(int j=i;j;--j){
			if(cmp(f[j-1],j-1,j,i)){
				f[i]=j;break;
			}
		}
	}
	int i=n;
	while((i&gt;=f[n]||(!a[i]))&amp;&amp;i){
		g[i]=n;
		--i;
	}
	for(;i;--i){
		g[i]=i;
		for(int j=n-1;j&gt;i;--j){
			if(cmp(i,j,j+1,g[j+1])){
				g[i]=j;
				break;
			}
		}
	}
	for(int i=1;i&lt;=n;i=g[i]+1){
		for(int j=i;j&lt;=g[i];++j){
			printf(&quot;%c&quot;,s[j]);
		}
		if(g[i]!=n)printf(&quot;,&quot;);
	}


</code></pre>
<p>就好了,然鹅这个复杂度高达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,需要优化<br>
一:hash+二分代替暴力检查<br>
二:改成刷表,然后线段树优化DP</p>
<pre><code class="language-cpp">int n;
char s[N];
unsigned ll a[N],pw[N];
inline void prework(){
	n=strlen(s+1);
	for(int i=1;i&lt;=n;++i){
		a[i]=a[i-1]*md+(s[i]-'0');
	}
}
unsigned ll get(int l,int r){return a[r]-a[l-1]*pw[r-l+1];}
inline bool cmp(int l1,int r1,int l2,int r2){
	int len1=r1-l1+1;
	int len2=r2-l2+1;
	if(len1&lt;len2)return 1;
	if(len2&lt;len1)return 0;
	int l=1,r=len1,mid,ans=0;
	while(l&lt;=r){
		mid=(l+r)&gt;&gt;1;
		if(get(l1,l1+mid-1)==get(l2,l2+mid-1))l=mid+1,ans=mid;
		else r=mid-1;
	}
	if(ans&gt;=len1)return 0;
	return s[l1+ans]&lt;s[l2+ans];
}
int l[N],r[N],f,g,flag[N&lt;&lt;2],t[N&lt;&lt;2];
inline void update(int k,int l,int r,int L,int R,int val){
	if(L&lt;=l&amp;&amp;r&lt;=R){
		flag[k]=max(flag[k],val);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if(mid&gt;=L)update(k&lt;&lt;1,l,mid,L,R,val);
	if(mid&lt;R)update(k&lt;&lt;1|1,mid+1,r,L,R,val);
}
inline void pushdown(int k){
	if(flag[k]){
		flag[k&lt;&lt;1]=max(flag[k&lt;&lt;1],flag[k]);
		flag[k&lt;&lt;1|1]=max(flag[k&lt;&lt;1|1],flag[k]);
		flag[k]=0;
	}return;
}
inline int query(int k,int l,int r,int z){
	
	if(l==r){t[k]=max(t[k],flag[k]);flag[k]=0;return t[k];}
	pushdown(k);
	int mid=(l+r)&gt;&gt;1;
	if(z&lt;=mid)return query(k&lt;&lt;1,l,mid,z);
	else return query(k&lt;&lt;1|1,mid+1,r,z);
}
int main(){
	pw[0]=1ll;
	for(int i=1;i&lt;=N-5;++i)pw[i]=pw[i-1]*md;
	while(~scanf(&quot;%s&quot;,s+1)){

		prework();
		for(int i=1;i&lt;=n;++i)if(s[i]=='0')l[i]=l[i-1];else l[i]=i;
		r[n+1]=n+1;
		for(int i=n;i;--i)if(s[i]=='0')r[i]=r[i+1];else r[i]=i;
		memset(flag,0,sizeof(flag));
		memset(t,0,sizeof(t));
		update(1,1,n,r[1],n,1);
		for(int i=1;i&lt;n;++i){
			f=query(1,1,n,i);
			int nex=r[i+1]+i-r[f];
			if(!cmp(r[f],i,r[i+1],nex))++nex;
			//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot;   &quot;&lt;&lt;nex&lt;&lt;endl;
			if(nex&lt;=n)update(1,1,n,nex,n,i+1);
		}int z=query(1,1,n,n);
		//cout&lt;&lt;z&lt;&lt;endl;
		memset(flag,0,sizeof(flag));
		memset(t,0,sizeof(t));
		update(1,1,n,l[z-1]+1,n,n);
		while(z&gt;1){
			g=query(1,1,n,z);
			int k=g-r[z]+1;
			int y=l[max(z-1-k,0)]+1;
			if(!cmp(r[y],z-1,r[z],g))y=r[y]+1;
			update(1,1,n,y,z-1,z-1);
			z--;
		}
		int pos=query(1,1,n,1);
		//cout&lt;&lt;pos&lt;&lt;endl;
		for(int i=1;i&lt;=n;++i){
			putchar(s[i]);
			if(i==pos&amp;&amp;i!=n)putchar(','),pos=query(1,1,n,i+1);
		}
		puts(&quot;&quot;);
	}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NOI2013][动态规划][大模拟]]]></title>
        <id>https://miuyou.github.io/post/noi2013dong-tai-gui-hua-da-mo-ni/</id>
        <link href="https://miuyou.github.io/post/noi2013dong-tai-gui-hua-da-mo-ni/">
        </link>
        <updated>2020-12-21T11:05:29.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1398">P1398 [NOI2013]书法家</a></li>
</ul>
<p>属实脑瘫,不知道为啥挂掉了,最后提交了题解代码<br>
暴力DP,细节无数,以后闲着没事可以看看,还是有可取之处的</p>
<pre><code class="language-cpp">
for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;=m;++j){
			rd(b[i][j]);
			sum[i][j]=sum[i-1][j]+b[i][j];
		}
	}
	for(int i=0;i&lt;=8;++i)for(int j=0;j&lt;=150;++j)for(int k=0;k&lt;=150;++k)f[0][i][j][k]=INF;
	for(int i=0;i&lt;=150;++i)for(int j=0;j&lt;=150;++j)a[i][j]=INF;
	int now,pre,nex;
	now=1;
	pre=0;
	nex=2;
	int ans=INF;
	for(int k=1;k&lt;=m;++k){
		for(int i=1;i&lt;=n;++i){
			for(int j=i+1;j&lt;=n;++j){
				f[now][0][i][j]=max(f[pre][0][i][j],0)+sum[j][k]-sum[i-1][k];
			}
		}
		for(int i=1;i&lt;=n;++i){
			a[1][i]=f[pre][1][1][i];
			for(int j=2;j&lt;=i;++j){
				a[j][i]=max(a[j-1][i],f[pre][1][j][i]);
			}
		}
		
		for(int i=1;i&lt;=n;++i){
			f[now][1][i][i]=max(a[i][i],a[i-1][i-1])+b[i][k];
			for(int j=i+1;j&lt;=n;++j){
				f[now][1][i][j]=max(f[now][1][i][j-1]+sum[j][k]-sum[j-1][k],a[i][j]+sum[j][k]-sum[i-1][k]);
			}
		}

		for(int i=1;i&lt;n;++i){
			int mx=INF;
			for(int j=n-1;j&gt;=i;--j){
				mx=max(mx,f[pre][0][i][j+1]);
				f[now][1][i][j]=max(f[now][1][i][j],mx+sum[j][k]-sum[i-1][k]);
			}
		}
		for(int i=2;i&lt;=n;++i){
			int mx=INF;
			for(int j=i-1;j;--j){
				mx=max(mx,f[pre][1][j+1][i]);
				f[now][2][j][i]=max(f[pre][2][j][i],mx)+sum[i][k]-sum[j-1][k];
			}
		}


		int mx=INF;
		if(k!=1){
			for(int i=2;i&lt;=n;++i){
				for(int j=i-1;j;--j){
					mx=max(mx,f[nex][2][j][i]);
				}
			}
		}
		for(int i=1;i+1&lt;n;++i){
			for(int j=i+2;j&lt;=n;++j){
				f[now][3][i][j]=mx+sum[j][k]-sum[i-1][k];
				f[now][4][i][j]=max(f[pre][3][i][j],f[pre][4][i][j])+b[i][k]+b[j][k];
				f[now][5][i][j]=f[pre][4][i][j]+sum[j][k]-sum[i-1][k];
			}
		}


		mx=INF;
		if(k!=1){
			for(int i=1;i+1&lt;n;++i){
				for(int j=i+2;j&lt;=n;++j){
					mx=max(mx,f[nex][5][i][j]);
				}
			}
		}
		for(int i=1;i+1&lt;n;++i){
			for(int j=i+2;j&lt;=n;++j){
				f[now][6][i][j]=max(mx,f[pre][6][i][j])+b[i][k]+b[j][k];
				f[now][7][i][j]=max(f[pre][6][i][j],f[pre][7][i][j])+sum[j][k]-sum[i-1][k];
				f[now][8][i][j]=max(f[pre][7][i][j],f[pre][8][i][j])+b[i][k]+b[j][k];
				
				ans=max(ans,f[now][8][i][j]);
			}
		}
		/*for(int z=0;z&lt;9;z++){
        	for(int i=0;i&lt;=n;i++){
         	   for(int j=0;j&lt;=n;j++){
                cout&lt;&lt;f[now][z][i][j]&lt;&lt;&quot; &quot;;
        	    }cout&lt;&lt;endl;
       	 	}cout&lt;&lt;endl;
   		 } 
		cout&lt;&lt;&quot;  !!!!  &quot;&lt;&lt;endl;*/
		++now;
		++pre;
		++nex;
		if(now&gt;=3)now=0;
		if(pre&gt;=3)pre=0;
		if(nex&gt;=3)nex=0;
	}
	cout&lt;&lt;ans&lt;&lt;endl;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[花园][动态规划][状态压缩][矩阵转移]]]></title>
        <id>https://miuyou.github.io/post/hua-yuan-dong-tai-gui-hua-zhuang-tai-ya-suo-ju-zhen-zhuan-yi/</id>
        <link href="https://miuyou.github.io/post/hua-yuan-dong-tai-gui-hua-zhuang-tai-ya-suo-ju-zhen-zhuan-yi/">
        </link>
        <updated>2020-12-21T06:50:53.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1357">P1357 花园</a></li>
</ul>
<p>数据范围一看就是要矩阵快速幂<br>
考虑直接在序列上转移,发现行不通....<br>
换个角度把每一段的状态给他状压一下,求出可行性矩阵,然后加速一下</p>
<pre><code class="language-cpp">
ll n,m,k;
int list[N],num;
inline int bit(int x){
	int nm=0;
	while(x){
		if(x&amp;1)++nm;
		x&gt;&gt;=1;
	}return nm;
}

struct SpringWait{
	ll f[N][N];
	SpringWait(){memset(f,0,sizeof(f));}
}a;
inline SpringWait operator *(SpringWait x,SpringWait y){
	SpringWait z;
	for(int k=1;k&lt;=num;++k)
	for(int i=1;i&lt;=num;++i){
		for(int j=1;j&lt;=num;++j){
			z.f[i][j]=(z.f[i][j]+1ll*x.f[i][k]*y.f[k][j]%mod)%mod;
		}
	}return z;
}
inline SpringWait ksm(SpringWait x,ll y){
	SpringWait ans;
	for(int i=1;i&lt;=num;++i){
		ans.f[i][i]=1ll;
	}
	while(y){
		if(y&amp;1)ans=ans*x;
		x=x*x;
		y&gt;&gt;=1;
	}return ans;
}
int tp[N];
int main(){
	rd(n);rd(m);rd(k);
	for(int i=0;i&lt;(1&lt;&lt;m);++i)if(bit(i)&lt;=k)list[++num]=i,tp[i]=num;
	for(int i=1;i&lt;=num;++i){
		a.f[i][tp[(list[i]&gt;&gt;1)]]=1;
		a.f[i][tp[(list[i]&gt;&gt;1)|(1&lt;&lt;(m-1))]]=1;

	}

	SpringWait b=ksm(a,n);
	ll ans=0;
	for(int i=1;i&lt;=num;++i){
		ans=(ans+b.f[i][i])%mod;
	}
	printf(&quot;%lld\n&quot;,ans);
	system(&quot;Pause&quot;);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[倒逆之战]]></title>
        <id>https://miuyou.github.io/post/dao-ni-zhi-zhan/</id>
        <link href="https://miuyou.github.io/post/dao-ni-zhi-zhan/">
        </link>
        <updated>2020-12-21T05:46:38.000Z</updated>
        <content type="html"><![CDATA[<p>2020.12.21决定命运的选择</p>
<p>---- 喝了教练泡的感冒药!好耶!</p>
<p>---- 脑瘫模拟DP,死了死了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[队员分组][动态规划][二分图][01背包]]]></title>
        <id>https://miuyou.github.io/post/dui-yuan-fen-zu-dong-tai-gui-hua-er-fen-tu-01-bei-bao/</id>
        <link href="https://miuyou.github.io/post/dui-yuan-fen-zu-dong-tai-gui-hua-er-fen-tu-01-bei-bao/">
        </link>
        <updated>2020-12-20T15:41:23.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1285">P1285 队员分组</a></li>
</ul>
<p>仔细思考发现有向图可以转化成无向图,发现彼此冲突的点对对答案有影响,冲突点对连边,二分图性质显然,但是这个可以由多个连通图组成,彼此之间无影响,考虑分组进行01背包就做完了</p>
<pre><code class="language-cpp">
inline void dfs(int x,int fa,int se){
	col[x]=se;
	V[tsum][se].push_back(x);
	++num[tsum][se];
	for(int i=1;i&lt;=n;++i){
		if(i==fa||i==x)continue;
		if(!tu[x][i]){
			if(!col[i]){
				dfs(i,x,3-se);
			}else if(col[i]==se){
				puts(&quot;No solution&quot;);
				exit(0);
			}
		}
	}
}
int f[N][N],pre[N][N];
bool vis[N];
int main(){
	rd(n);
	for(int i=1,x;i&lt;=n;++i){
		rd(x);
		while(x){
			tu[i][x]=1;
			rd(x);
		}
	}
	for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;=n;++j){
			if(i!=j){
				if(tu[i][j]&amp;&amp;tu[j][i])continue;
				tu[i][j]=tu[i][j]=0;
			}
		}
	}
	for(int i=1;i&lt;=n;++i){
		if(!col[i]){
			++tsum;
			dfs(i,0,1);
		}
	}
	pre[0][0]=1;
	for(int i=1;i&lt;=tsum;++i){
		for(int j=1;j&lt;=n/2;++j){
			int k=j-num[i][1];
			if(k&gt;=0){if(pre[i-1][k])pre[i][j]=1;}
			k=j-num[i][2];
			if(k&gt;=0){if(pre[i-1][k])pre[i][j]=2;}
		}
	}
	int ans=n/2;
	for(int i=n/2;i;--i)if(pre[tsum][i]){ans=i;break;}
	printf(&quot;%d &quot;,ans);
	for(int i=tsum;i;--i){
		for(int j=0;j&lt;V[i][pre[i][ans]].size();++j)vis[V[i][pre[i][ans]][j]]=1;
		ans-=num[i][pre[i][ans]];
	}
	for(int i=1;i&lt;=n;++i)if(vis[i])printf(&quot;%d &quot;,i),++ans;
	printf(&quot;\n%d &quot;,n-ans);
	for(int i=1;i&lt;=n;++i)if(!vis[i])printf(&quot;%d &quot;,i);
	system(&quot;Pause&quot;);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[春卷の博弈论]]></title>
        <id>https://miuyou.github.io/post/chun-juan-nobo-yi-lun/</id>
        <link href="https://miuyou.github.io/post/chun-juan-nobo-yi-lun/">
        </link>
        <updated>2020-11-23T11:36:08.000Z</updated>
        <content type="html"><![CDATA[<p>定义 Nim 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>a</mi><mn>2</mn></msub><mo>⊕</mo><mo>…</mo><mo>⊕</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">=a_1 \oplus a_2 \oplus \ldots \oplus a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</p>
<p>当且仅当 Nim 和为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，该状态为必败状态；否则该状态为必胜状态。</p>
<p>在一个有向无环图中，只有一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负。</p>
<p>定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">mex</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{mex}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">x</span></span></span></span></span> 函数的值为不属于集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 中的最小非负整数，即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">mex</mi><mo>⁡</mo><mo>(</mo><mi>S</mi><mo>)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>{</mo><mi>x</mi><mo>}</mo><mspace width="1em"/><mo>(</mo><mi>x</mi><mi mathvariant="normal">∉</mi><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mo>∈</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\operatorname{mex}(S)=\min\{x\} \quad (x \notin S, x \in N)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">x</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mclose">}</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<p>例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">mex</mi><mo>⁡</mo><mo>(</mo><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo>}</mo><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\operatorname{mex}(\{0, 2, 4\})=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">x</span></span><span class="mopen">(</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">mex</mi><mo>⁡</mo><mo>(</mo><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>}</mo><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\operatorname{mex}(\{1, 2\})=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">x</span></span><span class="mopen">(</span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 。</p>
<p>对于状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和它的所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个后继状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>y</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">y_1, y_2, \ldots, y_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">SG</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\operatorname{SG}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">G</span></span></span></span></span> 函数：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">SG</mi><mo>⁡</mo><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">mex</mi><mo>⁡</mo><mo>{</mo><mi mathvariant="normal">SG</mi><mo>⁡</mo><mo>(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">SG</mi><mo>⁡</mo><mo>(</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi mathvariant="normal">SG</mi><mo>⁡</mo><mo>(</mo><msub><mi>y</mi><mi>k</mi></msub><mo>)</mo><mo>}</mo></mrow><annotation encoding="application/x-tex">\operatorname{SG}(x)=\operatorname{mex}\{\operatorname{SG}(y_1), \operatorname{SG}(y_2), \ldots, \operatorname{SG}(y_k)\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">G</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">x</span></span><span class="mopen">{</span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">G</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">G</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">G</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p>
<p>而对于由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个有向图游戏组成的组合游戏，设它们的起点分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>s</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">s_1, s_2, \ldots, s_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则有定理： <strong>当且仅当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">SG</mi><mo>⁡</mo><mo>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo>)</mo><mo>⊕</mo><mi mathvariant="normal">SG</mi><mo>⁡</mo><mo>(</mo><msub><mi>s</mi><mn>2</mn></msub><mo>)</mo><mo>⊕</mo><mo>…</mo><mo>⊕</mo><mi mathvariant="normal">SG</mi><mo>⁡</mo><mo>(</mo><msub><mi>s</mi><mi>n</mi></msub><mo>)</mo><mi mathvariant="normal">≠</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \ldots \oplus \operatorname{SG}(s_n) \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">G</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">G</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">G</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，这个游戏是先手必胜的。</strong></p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P6665">P6665 [清华集训2016] Alice 和 Bob 又在玩游戏</a></li>
</ul>
<p>子树互相独立,对于每颗子树,要么删根要么删子节点,删根把子节点全部异或起来就行了,删子节点则要异或上其他子树,则需要全局异或/全局查询/合并/插入,01trie解决即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Miu_you の动态规划]]></title>
        <id>https://miuyou.github.io/post/miu_you-nodong-tai-gui-hua/</id>
        <link href="https://miuyou.github.io/post/miu_you-nodong-tai-gui-hua/">
        </link>
        <updated>2020-11-06T01:26:12.000Z</updated>
        <summary type="html"><![CDATA[<p>动态规划也炒鸡可爱的说!<br>
<img src="https://miuyou.github.io//post-images/1583457992014.jpg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>动态规划也炒鸡可爱的说!<br>
<img src="https://miuyou.github.io//post-images/1583457992014.jpg" alt="" loading="lazy"></p>
<!-- more -->
<p>欸,这篇废了,等所有子文章编辑完成了再来搞</p>
<h2 id="树形dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">树</mi><mi mathvariant="normal">形</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">树形DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">形</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1131">P1131 [ZJOI2007]时态同步</a><br>
简单树形DP,让所有点都和最慢得一样慢就可以了</li>
</ul>
<h2 id="杂类dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">杂</mi><mi mathvariant="normal">类</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">杂类DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">杂</span><span class="mord cjk_fallback">类</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1169">P1169 [ZJOI2007]棋盘制作</a><br>
悬线法</li>
<li><a href="https://www.luogu.com.cn/problem/P1437">P1437 [HNOI2004]敲砖块</a><br>
一般向DP</li>
<li><a href="https://www.luogu.com.cn/problem/P1841">P1841 [JSOI2007]重要的城市</a><br>
无可取代得最短路经过点为重要城市,也不知道和dp有什么关系</li>
<li><a href="https://www.luogu.com.cn/problem/P1772">P1772 [ZJOI2006]物流运输</a><br>
奇怪のDP,发现无法简单得跑一个分层图最短路,因为有着更改路径得操作,那么就要dp了,枚举是什么时候更改路径得</li>
</ul>
<h2 id="数学dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">学</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">数学DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">学</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1450">P1450 [HAOI2008]硬币购物</a><br>
是榕树,我死了,不合法方案为强制选<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+1个</li>
<li><a href="https://www.luogu.com.cn/problem/P2059">P2059 [JLOI2013]卡牌游戏</a><br>
窝又死了,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第i个人经过j-1轮会胜出,因为他的位置在不断变化,所以每次把庄家提到1的位置上,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">/</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">f_{i,j}+=f_{x,j-1}/m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault">m</span></span></span></span>,x为当前位置-新的庄家的位置</li>
<li><a href="https://www.luogu.com.cn/problem/P2473">P2473 [SCOI2008]奖励关</a><br>
考虑到正着dp甚至不知道要输出什么,考虑反过来,代码不用改多少就变成反着的啦,然后就加加加就行了,考虑到有可能当前集合已经选过当前礼品了,所以也可以取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mi mathvariant="normal">∣</mi><mo>(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>)</mo></mrow></msub><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub></mrow></mrow><annotation encoding="application/x-tex">max{dp_{i+1,j|(...)},dp_{i+1,j}+a_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">∣</span><span class="mopen mtight">(</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>,因为题目说了&quot;假设你采取最优策略&quot;那么在能够选择拿或不拿的时候,自然拿走期望最高的啦</li>
</ul>
<h2 id="状态压缩dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">状</mi><mi mathvariant="normal">态</mi><mi mathvariant="normal">压</mi><mi mathvariant="normal">缩</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">状态压缩DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">压</span><span class="mord cjk_fallback">缩</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1896">P1896 [SCOI2005]互不侵犯</a><br>
简单的状态压缩</li>
</ul>
<h2 id="神仙dp"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">神</mi><mi mathvariant="normal">仙</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">神仙DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">神</span><span class="mord cjk_fallback">仙</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2051">P2051 [AHOI2009]中国象棋</a><br>
数据太大了,没法状态压缩,那么就dp喽,要详细的考虑到每种情况</li>
<li><a href="https://www.luogu.com.cn/problem/P4158">P4158 [SCOI2009]粉刷匠</a><br>
比较难想又比较难写的DP,其实熟练以后会觉得挺好写的.</li>
</ul>
]]></content>
    </entry>
</feed>