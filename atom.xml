<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://miuyou.github.io/</id>
    <title>春待ち</title>
    <updated>2020-12-29T08:25:09.546Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://miuyou.github.io/"/>
    <link rel="self" href="https://miuyou.github.io/atom.xml"/>
    <subtitle>开端顺利 自这天起 离乡背井 等候春息  身处何地 等候春息</subtitle>
    <logo>https://miuyou.github.io/images/avatar.png</logo>
    <icon>https://miuyou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 春待ち</rights>
    <entry>
        <title type="html"><![CDATA[[SDOI2007游戏][字符串][HASH]]]></title>
        <id>https://miuyou.github.io/post/sdoi2007-you-xi-zi-fu-chuan-hash/</id>
        <link href="https://miuyou.github.io/post/sdoi2007-you-xi-zi-fu-chuan-hash/">
        </link>
        <updated>2020-12-29T08:21:05.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2462">P2462 [SDOI2007]游戏</a></li>
</ul>
<p>简单题,要咋做就咋做就行了,给他hash一下分层DP</p>
<pre><code class="language-cpp">
n=1;
	while(~scanf(&quot;%s&quot;,ss+1)){
		
		a[n].len=strlen(ss+1);
		for(int i=1;i&lt;=a[n].len;++i)a[n].s[i]=ss[i];
		++n;
	}--n;
	sort(a+1,a+1+n);
	int len=a[1].len;
	pw[0]=1ll;
	for(int i=1;i&lt;=100;++i)pw[i]=pw[i-1]*base%mod;
	int tp=1;
	for(int i=1;i&lt;=n&amp;&amp;a[i].len==len;++i){
		f[i]=1;
		insert(i);++tp;
	}
	if(tp==n+1){
		cout&lt;&lt;1&lt;&lt;endl;
		cout&lt;&lt;a[1].s&lt;&lt;endl;
	}else{
		for(int i=tp;i&lt;=n;i=tp){
			for(tp=i;tp&lt;=n&amp;&amp;a[tp].len==a[i].len;++tp){
				int x=get(tp);
				int y=x;
				f[tp]=1;
				for(int j=1;j&lt;=a[tp].len;++j){
					x=((y-pw[a[tp].s[j]-'a'])%mod+mod)%mod;
					if(g[x]){
						if(ha[x]+1&gt;f[tp]){
							f[tp]=ha[x]+1;
							nex[tp]=g[x];
						}
					}
				}
			}memset(ha,0,sizeof(ha));memset(g,0,sizeof(g));
			for(int j=i;j&lt;tp;++j){
				insert(j);
			} 
		}
		int pt=1;
		for(int i=1;i&lt;=n;++i){
			if(f[i]&gt;f[pt]){
				pt=i;
			}
		}
		cout&lt;&lt;f[pt]&lt;&lt;endl;
		dfs(pt);
	}	

    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[yyy's love IV][线段树DP]]]></title>
        <id>https://miuyou.github.io/post/yyys-love-ivxian-duan-shu-dp/</id>
        <link href="https://miuyou.github.io/post/yyys-love-ivxian-duan-shu-dp/">
        </link>
        <updated>2020-12-27T15:45:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2418">P2418 yyy loves OI IV</a></li>
</ul>
<p>我光想想就硬了(指拳头)</p>
<p>很容易想,需要处理的是快速查询可行区间最小值,使用线段树即可,至于臭味相投的人那就另外整点东西处理下就行了</p>
<p>注意:线段树是建立在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>轴上的,包括负区间....</p>
<pre><code class="language-cpp">int x[N],y[N],X[N],Y[N],g[N];
int main(){
	rd(n);rd(m);
	for(int i=1;i&lt;=n;++i){
		rd(a[i]);
		if(a[i]==1)a[i]=-1;
		else a[i]=1;
		x[i]=x[i-1]+(a[i]==-1);
		y[i]=y[i-1]+(a[i]==1);
	}
	memset(t,0x3f,sizeof(t));
	memset(g,0x3f,sizeof(g));
	memset(X,0x3f,sizeof(X));
	memset(Y,0x3f,sizeof(Y));
	update(1,-M,M,0,0);
	X[0]=Y[0]=g[M]=0;
	int opt,num;
	opt=0;num=0;
	f[0]=0;
	for(int i=1;i&lt;=n;++i){
		sum[i]=sum[i-1]+a[i];
		f[i]=query(1,-M,M,max(sum[i]-m,-M),min(M,sum[i]+m))+1;
		f[i]=min(f[i],f[i-1]+1);
		f[i]=min(f[i],X[x[i]]+1);
		f[i]=min(f[i],Y[y[i]]+1);
		X[x[i]]=min(f[i],X[x[i]]);
		Y[y[i]]=min(f[i],Y[y[i]]);
		update(1,-M,M,sum[i],f[i]);
	}
	cout&lt;&lt;f[n]&lt;&lt;endl;
	system(&quot;Pause&quot;);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2006字符串拼接][字符串][BFS][AC自动机]]]></title>
        <id>https://miuyou.github.io/post/hnoi2006-zi-fu-chuan-pin-jie-zi-fu-chuan-bfsac-zi-dong-ji/</id>
        <link href="https://miuyou.github.io/post/hnoi2006-zi-fu-chuan-pin-jie-zi-fu-chuan-bfsac-zi-dong-ji/">
        </link>
        <updated>2020-12-26T15:15:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2322">P2322 [HNOI2006]最短母串问题</a></li>
</ul>
<p>首先建个自动机出来,同时处理一下每个叶子结点有哪些节点<br>
然后就是直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">BFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>,性质自然</p>
<pre><code class="language-cpp">short n,cnt,ch[N][26];
char s[N];
int date[N];
inline void ins(int zi){
	int len=strlen(s),now=1;
	for(int i=0;i&lt;len;++i){
		int x=s[i]-'A';
		if(!ch[now][x]){
			ch[now][x]=++cnt;
		}now=ch[now][x];
	}
	date[now]|=(1&lt;&lt;zi);
	//cout&lt;&lt;now&lt;&lt;endl;
}
short q[N],l,r,fail[N];
void FA(){
	r=-1;
	for(int i=0;i&lt;=25;++i)ch[0][i]=1;
	q[++r]=1;
	while(l&lt;=r){
		int x=q[l];++l;
		for(int i=0;i&lt;=25;++i){
			if(ch[x][i]){
				fail[ch[x][i]]=ch[fail[x]][i];
				date[ch[x][i]]|=date[ch[fail[x]][i]];
				q[++r]=ch[x][i];
			}else{
				ch[x][i]=ch[fail[x]][i];
			}
		}
	}
}

queue&lt;int&gt;now,son;
bool vis[N][M];
char ans[N*M];
int nex[N*M];
int main(){
	cin&gt;&gt;n;cnt=1;
	for(int i=0;i&lt;n;++i){
		scanf(&quot;%s&quot;,s);
		ins(i);
	}
	FA();
	now.push(1);
	son.push(0);
	int num=0,sum=0;
	vis[0][0]=1;
	while(now.size()){
		int xnow=now.front();
		int xson=son.front();
		now.pop();
		son.pop();
		if(xson==((1&lt;&lt;n)-1)){
			int le=0;
			while(num){
				s[++le]=ans[num];
				num=nex[num];
			}
			while(le)putchar(s[le--]);
			break;
		}
		for(int i=0;i&lt;=25;++i){
			if(!vis[ch[xnow][i]][xson|date[ch[xnow][i]]]){
				vis[ch[xnow][i]][xson|date[ch[xnow][i]]]=1;
				now.push(ch[xnow][i]);
				son.push(xson|date[ch[xnow][i]]);
				nex[++sum]=num;
				ans[sum]='A'+i;
			}
		}
		++num;
	}
	system(&quot;Pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2005星际贸易][动态规划][单调队列优化][背包路径]]]></title>
        <id>https://miuyou.github.io/post/hnoi2005-xing-ji-mao-yi-dong-tai-gui-hua-dan-diao-dui-lie-you-hua-bei-bao-lu-jing/</id>
        <link href="https://miuyou.github.io/post/hnoi2005-xing-ji-mao-yi-dong-tai-gui-hua-dan-diao-dui-lie-you-hua-bei-bao-lu-jing/">
        </link>
        <updated>2020-12-26T15:09:00.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2317">P2317 [HNOI2005]星际贸易</a></li>
</ul>
<p>首先背包求出第一问,并且得到所有强制要选的点</p>
<p>那么接下来就是要最下化满足要求的路径花费</p>
<p>发现转移就俩种,要么从某个点飞过来要么原地加油,枚举某个点以及油量,复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,用单调队列搞搞就能优化成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>然鹅这题在背包部分翻车了....不该省的不要省,多重背包做不到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>的空间复杂度的</p>
<pre><code class="language-cpp">
 rd(n);rd(m);rd(RR);rd(LL);
    RR=min(RR,2*n);
    for(int i=1;i&lt;=n;++i){
        rd(a[i]);rd(b[i]);rd(l[i]);rd(p[i]);rd(f[i]);
    }
    for(int i=1;i&lt;=n;++i){
        if(l[i]-l[i-1]&gt;LL){
            puts(&quot;Poor Coke!&quot;);return 0;
        }
    }
    memset(bb,-1,sizeof(bb));
    bb[0][0]=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=0;j&lt;=m;++j){
            if(bb[i-1][j]&gt;=0)bb[i][j]=bb[i-1][j];
            if(j&gt;=a[i]&amp;&amp;bb[i-1][j-a[i]]&gt;=0){
                bb[i][j]=max(bb[i][j],bb[i-1][j-a[i]]+b[i]);
            }
        }
    }
    int an=0;int tp=0;
    for(int i=0;i&lt;=m;++i)if(bb[n][i]&gt;bb[n][an])an=i;
    for(int i=n,j=an;i;--i){
        if(bb[i][j]==bb[i-1][j])continue;
        else vis[i]=1,j-=a[i];
    }an=bb[n][an];
    
    memset(dp,0x3f,sizeof(dp));
    for(int i=0;i&lt;=RR;++i)L[i]=1;
    dp[0][RR]=0;
    q[RR][++R[RR]]=0;
    vis[n]=1;
    for(int i=1;i&lt;=n;++i){
        for(int j=0;j&lt;=RR;++j){
            if(p[i]&gt;0&amp;&amp;j&gt;0)dp[i][j]=min(dp[i][j],dp[i][j-1]+p[i]);
          
            if(L[j+2]&lt;=R[j+2])
            dp[i][j]=min(dp[i][j],dp[q[j+2][L[j+2]]][j+2]+f[i]);
            if(vis[i])L[j]=1,R[j]=0;
            while(L[j]&lt;=R[j]&amp;&amp;(dp[q[j][R[j]]][j]&gt;=dp[i][j]))--R[j];
            q[j][++R[j]]=i;
              while (L[j]&lt;=R[j]&amp;&amp;(l[i+1]-l[q[j][L[j]]]&gt;LL))++L[j];
        }
    }
    int ans=0;
    for(int i=0;i&lt;=RR;++i){if(dp[n][i]&lt;dp[n][ans])ans=i;//cout&lt;&lt;dp[n][i]&lt;&lt;endl;
    };
    if(dp[n][ans]==dp[0][0])puts(&quot;Poor Coke!&quot;);
    else printf(&quot;%d %d&quot;,an,an-dp[n][ans]);


    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[逛庙会][动态规划][状态压缩]]]></title>
        <id>https://miuyou.github.io/post/guang-miao-hui-dong-tai-gui-hua-zhuang-tai-ya-suo/</id>
        <link href="https://miuyou.github.io/post/guang-miao-hui-dong-tai-gui-hua-zhuang-tai-ya-suo/">
        </link>
        <updated>2020-12-25T14:06:44.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2238">P2238 逛庙会</a></li>
</ul>
<p>还算不错的题.....考虑俩种转移方式产生的不确定因素,将其状态压缩然后转移</p>
<pre><code class="language-cpp">
  for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]+1);
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            if(s[i][j]=='.'){
                a[i][j]=0;
            }else{
                a[i][j]=s[i][j]-'0';
            }
        }
    }
    int mn=15;
    memset(b,0x3f,sizeof(b));
    b[1][1][mn]=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            for(int x=0;x&lt;=mn;++x){
                for(int y=0;y&lt;=mn;++y){
                    if((((x&amp;4)==0)!=((y&amp;8)==0))||(!(x&amp;1))||(((x&amp;2)!=0)+((y&amp;1)!=0)+((y&amp;4)!=0)&lt;=1))continue;
                    int ans=b[i][j][x];
                    if(y&amp;4)ans+=a[i+1][j+1];
                    if(y&amp;2)ans+=a[i-1][j+2];
                    if(y&amp;1)ans+=a[i][j+2];
                    b[i][j+1][y]=min(b[i][j+1][y],ans);
                }
                for(int y=0;y&lt;=mn;++y){
                     if((((x&amp;1)==0)!=((y&amp;2)==0))||(!(x&amp;4))||(((x&amp;8)!=0)+((y&amp;1)!=0)+((y&amp;4)!=0)&lt;=1))continue;
                    int ans=b[i][j][x];
                    if(y&amp;1)ans+=a[i+1][j+1];
                    if(y&amp;4)ans+=a[i+2][j];
                    if(y&amp;8)ans+=a[i+2][j-1];
                    b[i+1][j][y]=min(b[i+1][j][y],ans);
                }
            }
        }
    }
    cout&lt;&lt;b[n][m][15]&lt;&lt;endl;

    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[SHOI2009舞会][动态规划][计数]]]></title>
        <id>https://miuyou.github.io/post/shoi2009-wu-hui-dong-tai-gui-hua-ji-shu/</id>
        <link href="https://miuyou.github.io/post/shoi2009-wu-hui-dong-tai-gui-hua-ji-shu/">
        </link>
        <updated>2020-12-24T10:53:35.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2159">P2159 [SHOI2009]舞会</a></li>
</ul>
<p>很神啊,啪的一下,我就被秒了</p>
<p>俩个轴,考虑固定男生,然后去逐位匹配女生,发现每次加入一个男生无法统计...那么考虑同时加入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,i号要么男生高,<br>
然后考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>&gt;</mo><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_j&gt;=y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>个,以及剩下的j个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>&lt;</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j&lt;y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都不需要特殊处理,再加上自己<br>
需要特殊处理的只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>&lt;</mo><mo>=</mo><msub><mi>x</mi><mi>j</mi></msub><mo>&lt;</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_j&lt;=x_j&lt;y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>s</mi><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i-s-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></p>
<p>需要着重注意一些性质,例如本题的有序性,有序是我们计数的关键条件</p>
<pre><code class="language-cpp">
rd(n);rd(k);
	for(int i=1;i&lt;=n;++i){
		rd(a[i]);
	}for(int i=1;i&lt;=n;++i){
		rd(b[i]);
	}
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;i;++j){
			c[i]+=(a[j]&gt;=b[i]);
			d[i]+=(b[j]&gt;a[i]);
		}
	}
	dp[0][0]=1;
	for(int i=1;i&lt;=n;++i){
		if(a[i]&gt;=b[i])
		for(int j=0;j&lt;=min(n,k);++j){
			SpringWait x;
			x=(c[i]+j+1);
			dp[i][j]+=x*dp[i-1][j];
			if(!j)continue;
			x=(i-c[i]-j);
			if(i-c[i]-j)
			dp[i][j]+=x*dp[i-1][j-1];
		}else{
			for(int j=1;j&lt;=min(n,k);++j){
				SpringWait x;
				x=(d[i]+i-j+1);
				dp[i][j]+=x*dp[i-1][j-1];
				x=(j-d[i]);
				if(j-d[i]&gt;0)
				dp[i][j]+=x*dp[i-1][j];
			}
		}
	}
	SpringWait ans;
	for(int i=0;i&lt;=k;++i){
		ans=(ans+dp[n][i]);
	}

    ```

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[排队打饭][动态规划][不错的状态压缩]]]></title>
        <id>https://miuyou.github.io/post/pai-dui-da-fan-dong-tai-gui-hua-bu-cuo-de-zhuang-tai-ya-suo/</id>
        <link href="https://miuyou.github.io/post/pai-dui-da-fan-dong-tai-gui-hua-bu-cuo-de-zhuang-tai-ya-suo/">
        </link>
        <updated>2020-12-23T16:09:04.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2157">P2157 [SDOI2009]学校食堂</a></li>
</ul>
<p>刚看到题目会觉得难以下手</p>
<p>考虑最难解决的是如何维护那些人吃过饭了那些人可以吃饭,发现大家的容忍度都不高,将其状态压缩,那么就可以传递那些人吃过了,然后考虑上一个是谁吃会影响到计算结果,那么再开一维记录上一个是谁,就可以转移啦.想当于每个点都要背包一下怎么选后面谁吃,然后转移到下一个人的前提是这个人吃过了.</p>
<pre><code class="language-cpp">
memset(f,0x3f,sizeof(f));
		f[1][0][7]=0;
		for(int i=1;i&lt;=n;++i){
			for(int j=0;j&lt;MAXN;++j){
				for(int k=-8;k&lt;=7;++k){
					if(f[i][j][k+8]!=f[0][0][0]){
						if(j&amp;1){
							f[i+1][j&gt;&gt;1][k+7]=min(f[i+1][j&gt;&gt;1][k+7],f[i][j][k+8]);
						}else{
							int r=f[0][0][0];
							for(int z=0;z&lt;=7;++z){
								if(j&amp;(1&lt;&lt;z))continue;
								if(i+z&gt;r)break;
								r=min(r,i+z+b[i+z]);
								f[i][j|(1&lt;&lt;z)][z+8]=min(f[i][j|(1&lt;&lt;z)][z+8],f[i][j][k+8]+((i+k)?(a[i+k]^a[i+z]):0));

							}
						}
					}
				}
			}
		}
		int ans=f[0][0][0];
		for(int i=0;i&lt;=8;++i){
			ans=min(ans,f[n+1][0][i]);
		//	cout&lt;&lt;f[n+1][0][i]&lt;&lt;endl;
		}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringWait's 置换]]></title>
        <id>https://miuyou.github.io/post/springwaits-zhi-huan/</id>
        <link href="https://miuyou.github.io/post/springwaits-zhi-huan/">
        </link>
        <updated>2020-12-22T17:11:39.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>u</mi><mi>r</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Burnside</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span> 引理： 对于一个置换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>，若一个着色方案<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 经过置换后不变，则称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的不动点。记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的不动点数目为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>，则等价类个数为所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> 的平均值。</p>
<p>例题- <a href="https://www.luogu.com.cn/problem/P1446">P1446 [HNOI2008]Cards</a></p>
<pre><code class="language-cpp">
ll n,r,b,g,m,p,a[M],f[N][N][N];
bool vis[M];
ll t[M],sum,siz[M];
inline ll work(){
	memset(vis,0,sizeof(vis));
	memset(f,0,sizeof(f));
	f[0][0][0]=1;sum=0;
	memset(siz,0,sizeof(siz));
	for(int i=1;i&lt;=n;++i){
		if(vis[i])continue;
		int x=i;
		++sum;
		while(!vis[x]){
			vis[x]=1;
			x=a[x];
			++siz[sum];
		}
	}
	for(int z=1;z&lt;=sum;++z){
		for(int i=r;~i;--i){
			for(int j=b;~j;--j){
				for(int k=g;~k;--k){
					if(i&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i-siz[z]][j][k])%p;
					if(j&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i][j-siz[z]][k])%p;
					if(k&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i][j][k-siz[z]])%p;
				}
			}
		}
	}
	return f[r][b][g];
}
inline ll ksm(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&amp;1)ans=1ll*ans*x%p;
		x=1ll*x*x%p;
		y&gt;&gt;=1;
	}return ans;
}
int main(){
	rd(r);rd(b);rd(g);rd(m);rd(p);
	n=r+b+g;
	int ans=0;
	for(int i=1;i&lt;=m;++i){
		for(int j=1;j&lt;=n;++j){
			rd(a[j]);
		}
		ans=(ans+work())%p;
	}
	for(int i=1;i&lt;=n;++i)a[i]=i;
	ans=(ans+work())%p;
	ans=1ll*ans*ksm(m+1,p-2)%p;
	cout&lt;&lt;ans&lt;&lt;endl;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[铁马落地][动态规划][线段树优化DP]]]></title>
        <id>https://miuyou.github.io/post/tie-ma-luo-di-dong-tai-gui-hua-xian-duan-shu-you-hua-dp/</id>
        <link href="https://miuyou.github.io/post/tie-ma-luo-di-dong-tai-gui-hua-xian-duan-shu-you-hua-dp/">
        </link>
        <updated>2020-12-22T16:53:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1442">P1442 铁球落地</a></li>
</ul>
<p>先弄一个假假的想法,发现影响复杂的是快速找到下一层,那么从下往上线段树区间覆盖就好了....</p>
<pre><code class="language-cpp">
struct SpringWait{
	int h,l,r;
}a[N];
inline bool operator &lt;(SpringWait a,SpringWait b){
	return a.h&lt;b.h;
}
int t[N],num;
int f[N],g[N],ls[N],rs[N],flag[N&lt;&lt;2];
inline void pushdown(int k){
	if(flag[k]){
		flag[k&lt;&lt;1]=flag[k];
		flag[k&lt;&lt;1|1]=flag[k];
		flag[k]=0;
	}
}
inline int query(int k,int l,int r,int x){
	if(l==r)return flag[k];
	pushdown(k);
	int mid=(l+r)&gt;&gt;1;
	if(x&lt;=mid)return query(k&lt;&lt;1,l,mid,x);
	else return query(k&lt;&lt;1|1,mid+1,r,x);
}
inline void update(int k,int l,int r,int L,int R,int x){
	if(L&lt;=l&amp;&amp;r&lt;=R){
		flag[k]=x;
	}else{
		int mid=(l+r)&gt;&gt;1;
		if(L&lt;=mid)update(k&lt;&lt;1,l,mid,L,R,x);
		if(R&gt;mid)update(k&lt;&lt;1|1,mid+1,r,L,R,x);
	}
}
int main(){
	rd(n);rd(h);
	int x,y;
	rd(x);rd(y);
	for(int i=1;i&lt;=n;++i){
		rd(a[i].h);rd(a[i].l);rd(a[i].r);
		t[++num]=a[i].l;
		t[++num]=a[i].r;
	}
	++n;
	a[n].l=a[n].r=x;
	a[n].h=y;
	t[++num]=x;
	sort(a+1,a+1+n);
	sort(t+1,t+1+num);
	//num=unique(t+1,t+1+num)-t-1;
	for(int i=1;i&lt;=n;++i){
		a[i].l=lower_bound(t+1,t+1+num,a[i].l)-t;
		a[i].r=lower_bound(t+1,t+1+num,a[i].r)-t;
	}
	for(int i=1;i&lt;=n;++i){
		ls[i]=query(1,1,num,a[i].l);
		rs[i]=query(1,1,num,a[i].r);
		update(1,1,num,a[i].l,a[i].r,i);
	}
	memset(f,0x3f,sizeof(f));
	memset(g,0x3f,sizeof(g));
	f[0]=g[0]=0;
	for(int i=1;i&lt;=n;++i){
		if(a[i].h-a[ls[i]].h&lt;=h){
			if(ls[i]){
				f[i]=min(f[i],f[ls[i]]+t[a[i].l]-t[a[ls[i]].l]+a[i].h-a[ls[i]].h);
				f[i]=min(f[i],g[ls[i]]-t[a[i].l]+t[a[ls[i]].r]+a[i].h-a[ls[i]].h);
			}else{
				f[i]=a[i].h;
			}
		}

		if(a[i].h-a[rs[i]].h&lt;=h){
			if(rs[i]){
				g[i]=min(g[i],f[rs[i]]+t[a[i].r]-t[a[rs[i]].l]+a[i].h-a[rs[i]].h);
				g[i]=min(g[i],g[rs[i]]-t[a[i].r]+t[a[rs[i]].r]+a[i].h-a[rs[i]].h);
			}else{
				g[i]=a[i].h;
			}
		}
	}
	printf(&quot;%d\n&quot;,min(f[n],g[n]));
	system(&quot;Pause&quot;);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2003历史年份][动态规划][线段树优化建图]]]></title>
        <id>https://miuyou.github.io/post/hnoi2003-li-shi-nian-fen-dong-tai-gui-hua-xian-duan-shu-you-hua-jian-tu/</id>
        <link href="https://miuyou.github.io/post/hnoi2003-li-shi-nian-fen-dong-tai-gui-hua-xian-duan-shu-you-hua-jian-tu/">
        </link>
        <updated>2020-12-22T08:34:28.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2282">P2282 [HNOI2003]历史年份</a></li>
</ul>
<p>orzzzzzzzzzzzzzzzzzzz</p>
<p>调了一天</p>
<p>让我们先把弱化版给切掉</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1415">P1415 拆分数列</a></li>
</ul>
<p>一路填表过去就好了,正着一次反着一次<br>
先求出最小后缀,发现对于每个值的左下标越靠近n越小<br>
然后倒着做回来,右下标越靠近n越nb</p>
<p>那么</p>
<pre><code class="language-cpp">

inline bool cmp(int l1,int r1,int l2,int r2){
	int len1=r1-l1+1;
	int len2=r2-l2+1;
	int s1=l1,s2=l2,e1=r1,e2=r2;
	while(!a[s1]){
		++s1;
		--len1;
	}
	while (!a[s2]){
		++s2;
		--len2;
	}
	if(len1&gt;len2)return 0;
	if(len1&lt;len2)return 1;
	for(int i=0;i&lt;len1;++i){
		if(a[s1+i]!=a[s2+i]){
			return 	a[s1+i]&lt;a[s2+i];
		}	
	}
	return 0;
}
int main(){
	scanf(&quot;%s&quot;,s+1);
	n=strlen(s+1);
	for(int i=1;i&lt;=n;++i){
		a[i]=s[i]-'0';
	}
	f[1]=1;
	for(int i=2;i&lt;=n;++i){
		for(int j=i;j;--j){
			if(cmp(f[j-1],j-1,j,i)){
				f[i]=j;break;
			}
		}
	}
	int i=n;
	while((i&gt;=f[n]||(!a[i]))&amp;&amp;i){
		g[i]=n;
		--i;
	}
	for(;i;--i){
		g[i]=i;
		for(int j=n-1;j&gt;i;--j){
			if(cmp(i,j,j+1,g[j+1])){
				g[i]=j;
				break;
			}
		}
	}
	for(int i=1;i&lt;=n;i=g[i]+1){
		for(int j=i;j&lt;=g[i];++j){
			printf(&quot;%c&quot;,s[j]);
		}
		if(g[i]!=n)printf(&quot;,&quot;);
	}


</code></pre>
<p>就好了,然鹅这个复杂度高达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,需要优化<br>
一:hash+二分代替暴力检查<br>
二:改成刷表,然后线段树优化DP</p>
<pre><code class="language-cpp">int n;
char s[N];
unsigned ll a[N],pw[N];
inline void prework(){
	n=strlen(s+1);
	for(int i=1;i&lt;=n;++i){
		a[i]=a[i-1]*md+(s[i]-'0');
	}
}
unsigned ll get(int l,int r){return a[r]-a[l-1]*pw[r-l+1];}
inline bool cmp(int l1,int r1,int l2,int r2){
	int len1=r1-l1+1;
	int len2=r2-l2+1;
	if(len1&lt;len2)return 1;
	if(len2&lt;len1)return 0;
	int l=1,r=len1,mid,ans=0;
	while(l&lt;=r){
		mid=(l+r)&gt;&gt;1;
		if(get(l1,l1+mid-1)==get(l2,l2+mid-1))l=mid+1,ans=mid;
		else r=mid-1;
	}
	if(ans&gt;=len1)return 0;
	return s[l1+ans]&lt;s[l2+ans];
}
int l[N],r[N],f,g,flag[N&lt;&lt;2],t[N&lt;&lt;2];
inline void update(int k,int l,int r,int L,int R,int val){
	if(L&lt;=l&amp;&amp;r&lt;=R){
		flag[k]=max(flag[k],val);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if(mid&gt;=L)update(k&lt;&lt;1,l,mid,L,R,val);
	if(mid&lt;R)update(k&lt;&lt;1|1,mid+1,r,L,R,val);
}
inline void pushdown(int k){
	if(flag[k]){
		flag[k&lt;&lt;1]=max(flag[k&lt;&lt;1],flag[k]);
		flag[k&lt;&lt;1|1]=max(flag[k&lt;&lt;1|1],flag[k]);
		flag[k]=0;
	}return;
}
inline int query(int k,int l,int r,int z){
	
	if(l==r){t[k]=max(t[k],flag[k]);flag[k]=0;return t[k];}
	pushdown(k);
	int mid=(l+r)&gt;&gt;1;
	if(z&lt;=mid)return query(k&lt;&lt;1,l,mid,z);
	else return query(k&lt;&lt;1|1,mid+1,r,z);
}
int main(){
	pw[0]=1ll;
	for(int i=1;i&lt;=N-5;++i)pw[i]=pw[i-1]*md;
	while(~scanf(&quot;%s&quot;,s+1)){

		prework();
		for(int i=1;i&lt;=n;++i)if(s[i]=='0')l[i]=l[i-1];else l[i]=i;
		r[n+1]=n+1;
		for(int i=n;i;--i)if(s[i]=='0')r[i]=r[i+1];else r[i]=i;
		memset(flag,0,sizeof(flag));
		memset(t,0,sizeof(t));
		update(1,1,n,r[1],n,1);
		for(int i=1;i&lt;n;++i){
			f=query(1,1,n,i);
			int nex=r[i+1]+i-r[f];
			if(!cmp(r[f],i,r[i+1],nex))++nex;
			//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot;   &quot;&lt;&lt;nex&lt;&lt;endl;
			if(nex&lt;=n)update(1,1,n,nex,n,i+1);
		}int z=query(1,1,n,n);
		//cout&lt;&lt;z&lt;&lt;endl;
		memset(flag,0,sizeof(flag));
		memset(t,0,sizeof(t));
		update(1,1,n,l[z-1]+1,n,n);
		while(z&gt;1){
			g=query(1,1,n,z);
			int k=g-r[z]+1;
			int y=l[max(z-1-k,0)]+1;
			if(!cmp(r[y],z-1,r[z],g))y=r[y]+1;
			update(1,1,n,y,z-1,z-1);
			z--;
		}
		int pos=query(1,1,n,1);
		//cout&lt;&lt;pos&lt;&lt;endl;
		for(int i=1;i&lt;=n;++i){
			putchar(s[i]);
			if(i==pos&amp;&amp;i!=n)putchar(','),pos=query(1,1,n,i+1);
		}
		puts(&quot;&quot;);
	}


</code></pre>
]]></content>
    </entry>
</feed>