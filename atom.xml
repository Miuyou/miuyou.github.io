<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://miuyou.github.io/</id>
    <title>春待ち</title>
    <updated>2021-01-09T07:46:14.872Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://miuyou.github.io/"/>
    <link rel="self" href="https://miuyou.github.io/atom.xml"/>
    <subtitle>开端顺利 自这天起 离乡背井 等候春息  身处何地 等候春息</subtitle>
    <logo>https://miuyou.github.io/images/avatar.png</logo>
    <icon>https://miuyou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 春待ち</rights>
    <entry>
        <title type="html"><![CDATA[[CF600E][启发式合并]]]></title>
        <id>https://miuyou.github.io/post/cf600eqi-fa-shi-he-bing/</id>
        <link href="https://miuyou.github.io/post/cf600eqi-fa-shi-he-bing/">
        </link>
        <updated>2021-01-09T07:44:58.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/CF600E">CF600E Lomsat gelral</a></li>
</ul>
<p>我是弟弟<br>
这都写错</p>
<pre><code class="language-cpp">
inline void work(int x,int fa,int z){
   // cout&lt;&lt;x&lt;&lt;&quot;  &quot;&lt;&lt;fa&lt;&lt;endl;
    ++sum[a[x]];
    if(sum[a[x]]&gt;top){
        num=0;
        top=sum[a[x]];
        num=a[x];
    }else if(sum[a[x]]==top){
        num+=a[x];
    }
    for(int i=firs[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa||y==z)continue;
        work(y,x,z);
    }
}
inline void init(int x,int fa){
    --sum[a[x]];
    for(int i=firs[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa)continue;
        init(y,x);
    }
}
inline void dfs(int x,int fa){
    for(int i=firs[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa||y==son[x])continue;
        dfs(y,x);
        init(y,x);
        num=top=0;
    }
    if(son[x]){
        dfs(son[x],x);
    }
    work(x,fa,son[x]);
    ans[x]=num;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[SDOI2011导弹拦截][CDQ][DP]]]></title>
        <id>https://miuyou.github.io/post/sdoi2011-dao-dan-lan-jie-cdqdp/</id>
        <link href="https://miuyou.github.io/post/sdoi2011-dao-dan-lan-jie-cdqdp/">
        </link>
        <updated>2021-01-01T04:18:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2487">P2487 [SDOI2011]拦截导弹</a><br>
拦了半天发现是自己人内鬼了<br>
首先一眼看出是CDQ,然后要求一个中间点的方案需要他往前和他往后,所以要倒过来再做一次CDQ</li>
</ul>
<pre><code class="language-cpp">int n;
struct SpringWait
{
	int a,b,f,id;
	db g;
}f[N],g[N];
inline bool cmp1(SpringWait X,SpringWait Y){
	return X.b&lt;Y.b;
}
inline bool cmp2(SpringWait X,SpringWait Y){
	return X.id&gt;Y.id;
}
inline bool cmp3(SpringWait X,SpringWait Y){
	return X.a&lt;Y.a;
}
inline bool cmp4(SpringWait X,SpringWait Y){
	return X.b&gt;Y.b;
}
inline bool cmp5(SpringWait X,SpringWait Y){
	return X.id&lt;Y.id;
}
inline bool cmp6(SpringWait X,SpringWait Y){
	return X.a&gt;Y.a;
}
int rk[N];
int tf[N];
db tg[N];
inline int lowbit(int x){
	return x&amp;(-x);
}
inline void insert(int x,int ff,db gg){
	while(x&lt;=n){
		if(tf[x]==ff){
			tg[x]+=gg;
		}else if(tf[x]&lt;ff){
			tg[x]=gg;
			tf[x]=ff;
		}
		x+=lowbit(x);
	}
}
inline void del(int x){
	while(x&lt;=n){
		tf[x]=0;
		tg[x]=0;
		x+=lowbit(x);
	}
}
inline void query(int x,int &amp;l,db &amp;r){
	while(x){
		if(l==tf[x]){
			r+=tg[x];
		}else if(l&lt;tf[x]){
			l=tf[x];
			r=tg[x];
		}
		x-=lowbit(x);
	}
}
inline void CDQ(int l,int r){
	if(l==r)return;
	int mid=(l+r)&gt;&gt;1;
	CDQ(l,mid);
	sort(f+1+mid,f+r+1,cmp3);
	int L=l;
	for(int R=mid+1;R&lt;=r;++R){
		while(f[L].a&lt;=f[R].a&amp;&amp;L&lt;=mid){
			insert(f[L].b,f[L].f,f[L].g);
			++L;
		}
		int ff=0;db gg=0;
		query(f[R].b,ff,gg);
		if(f[R].f&lt;ff+1){
			f[R].f=ff+1;
			f[R].g=gg;
		}else if(f[R].f==ff+1){
			f[R].g+=gg;
		}
	}
	for(int i=l;i&lt;=mid;++i)del(f[i].b);
	sort(f+mid+1,f+1+r,cmp2);
	CDQ(mid+1,r);
	sort(f+l,f+1+r,cmp3);
}
inline void CD(int l,int r){
	if(l==r)return;
	int mid=(l+r)&gt;&gt;1;
	CD(l,mid);
	sort(g+1+mid,g+r+1,cmp6);
	int L=l;
	for(int R=mid+1;R&lt;=r;++R){
		while(g[L].a&gt;=g[R].a&amp;&amp;L&lt;=mid){
			insert(g[L].b,g[L].f,g[L].g);
			++L;
		}
		int ff=0;db gg=0;
		query(g[R].b,ff,gg);
		if(g[R].f&lt;ff+1){
			g[R].f=ff+1;
			g[R].g=gg;
		}else if(g[R].f==ff+1){
			g[R].g+=gg;
		}
	}
	for(int i=l;i&lt;=mid;++i)del(g[i].b);
	sort(g+mid+1,g+1+r,cmp5);
	CD(mid+1,r);
	sort(g+l,g+1+r,cmp6);
}
int main(){
	rd(n);
	for(int i=1;i&lt;=n;++i){
		rd(f[i].a);rd(f[i].b);f[i].id=i;f[i].f=1;
		f[i].g=1.0;
		g[i]=f[i];
	}
	sort(f+1,f+1+n,cmp1);
	rk[1]=1;int tot=1;
	for(int i=2;i&lt;=n;++i){
		if(f[i].b==f[i-1].b){
			rk[i]=tot;
		}else {
			++tot;
			rk[i]=tot;
		}
	}
	for(int i=1;i&lt;=n;++i){
		f[i].b=rk[i];
	}sort(f+1,f+1+n,cmp2);
	CDQ(1,n);

	/*for(int i=1;i&lt;=n;++i){
		printf(&quot;%d %d %d %d %.5lf\n&quot;,f[i].a,f[i].b,f[i].id,f[i].f,f[i].g);
	}*/
	sort(g+1,g+1+n,cmp4);
	rk[1]=1;tot=1;
	for(int i=2;i&lt;=n;++i){
		if(g[i].b==g[i-1].b){
			rk[i]=tot;
		}else {
			++tot;
			rk[i]=tot;
		}
	}
	for(int i=1;i&lt;=n;++i){
		g[i].b=rk[i];
	}sort(g+1,g+1+n,cmp5);
	CD(1,n);
	/*for(int i=1;i&lt;=n;++i){
		printf(&quot;%d %d %d %d %.5lf\n&quot;,g[i].a,g[i].b,g[i].id,g[i].f,g[i].g);
	}*/
	sort(f+1,f+1+n,cmp5);
	sort(g+1,g+1+n,cmp5);
	int len=0;
	for(int i=1;i&lt;=n;++i){
		len=max(len,f[i].f);
	}
	cout&lt;&lt;len&lt;&lt;endl;
	db ans=0;
	for(int i=1;i&lt;=n;++i){
		if(f[i].f==len)ans+=f[i].g;
	}
	for(int i=1;i&lt;=n;++i){
		if(f[i].f+g[i].f-1==len){
			printf(&quot;%.5lf &quot;,(f[i].g*g[i].g)/ans);
		}else{
			printf(&quot;0.00000 &quot;);
		}
	}
	system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[SDOI2007游戏][字符串][HASH]]]></title>
        <id>https://miuyou.github.io/post/sdoi2007-you-xi-zi-fu-chuan-hash/</id>
        <link href="https://miuyou.github.io/post/sdoi2007-you-xi-zi-fu-chuan-hash/">
        </link>
        <updated>2020-12-29T08:21:05.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2462">P2462 [SDOI2007]游戏</a></li>
</ul>
<p>简单题,要咋做就咋做就行了,给他hash一下分层DP</p>
<pre><code class="language-cpp">
n=1;
	while(~scanf(&quot;%s&quot;,ss+1)){
		
		a[n].len=strlen(ss+1);
		for(int i=1;i&lt;=a[n].len;++i)a[n].s[i]=ss[i];
		++n;
	}--n;
	sort(a+1,a+1+n);
	int len=a[1].len;
	pw[0]=1ll;
	for(int i=1;i&lt;=100;++i)pw[i]=pw[i-1]*base%mod;
	int tp=1;
	for(int i=1;i&lt;=n&amp;&amp;a[i].len==len;++i){
		f[i]=1;
		insert(i);++tp;
	}
	if(tp==n+1){
		cout&lt;&lt;1&lt;&lt;endl;
		cout&lt;&lt;a[1].s&lt;&lt;endl;
	}else{
		for(int i=tp;i&lt;=n;i=tp){
			for(tp=i;tp&lt;=n&amp;&amp;a[tp].len==a[i].len;++tp){
				int x=get(tp);
				int y=x;
				f[tp]=1;
				for(int j=1;j&lt;=a[tp].len;++j){
					x=((y-pw[a[tp].s[j]-'a'])%mod+mod)%mod;
					if(g[x]){
						if(ha[x]+1&gt;f[tp]){
							f[tp]=ha[x]+1;
							nex[tp]=g[x];
						}
					}
				}
			}memset(ha,0,sizeof(ha));memset(g,0,sizeof(g));
			for(int j=i;j&lt;tp;++j){
				insert(j);
			} 
		}
		int pt=1;
		for(int i=1;i&lt;=n;++i){
			if(f[i]&gt;f[pt]){
				pt=i;
			}
		}
		cout&lt;&lt;f[pt]&lt;&lt;endl;
		dfs(pt);
	}	

    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[yyy's love IV][线段树DP]]]></title>
        <id>https://miuyou.github.io/post/yyys-love-ivxian-duan-shu-dp/</id>
        <link href="https://miuyou.github.io/post/yyys-love-ivxian-duan-shu-dp/">
        </link>
        <updated>2020-12-27T15:45:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2418">P2418 yyy loves OI IV</a></li>
</ul>
<p>我光想想就硬了(指拳头)</p>
<p>很容易想,需要处理的是快速查询可行区间最小值,使用线段树即可,至于臭味相投的人那就另外整点东西处理下就行了</p>
<p>注意:线段树是建立在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>轴上的,包括负区间....</p>
<pre><code class="language-cpp">int x[N],y[N],X[N],Y[N],g[N];
int main(){
	rd(n);rd(m);
	for(int i=1;i&lt;=n;++i){
		rd(a[i]);
		if(a[i]==1)a[i]=-1;
		else a[i]=1;
		x[i]=x[i-1]+(a[i]==-1);
		y[i]=y[i-1]+(a[i]==1);
	}
	memset(t,0x3f,sizeof(t));
	memset(g,0x3f,sizeof(g));
	memset(X,0x3f,sizeof(X));
	memset(Y,0x3f,sizeof(Y));
	update(1,-M,M,0,0);
	X[0]=Y[0]=g[M]=0;
	int opt,num;
	opt=0;num=0;
	f[0]=0;
	for(int i=1;i&lt;=n;++i){
		sum[i]=sum[i-1]+a[i];
		f[i]=query(1,-M,M,max(sum[i]-m,-M),min(M,sum[i]+m))+1;
		f[i]=min(f[i],f[i-1]+1);
		f[i]=min(f[i],X[x[i]]+1);
		f[i]=min(f[i],Y[y[i]]+1);
		X[x[i]]=min(f[i],X[x[i]]);
		Y[y[i]]=min(f[i],Y[y[i]]);
		update(1,-M,M,sum[i],f[i]);
	}
	cout&lt;&lt;f[n]&lt;&lt;endl;
	system(&quot;Pause&quot;);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2006字符串拼接][字符串][BFS][AC自动机]]]></title>
        <id>https://miuyou.github.io/post/hnoi2006-zi-fu-chuan-pin-jie-zi-fu-chuan-bfsac-zi-dong-ji/</id>
        <link href="https://miuyou.github.io/post/hnoi2006-zi-fu-chuan-pin-jie-zi-fu-chuan-bfsac-zi-dong-ji/">
        </link>
        <updated>2020-12-26T15:15:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2322">P2322 [HNOI2006]最短母串问题</a></li>
</ul>
<p>首先建个自动机出来,同时处理一下每个叶子结点有哪些节点<br>
然后就是直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">BFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>,性质自然</p>
<pre><code class="language-cpp">short n,cnt,ch[N][26];
char s[N];
int date[N];
inline void ins(int zi){
	int len=strlen(s),now=1;
	for(int i=0;i&lt;len;++i){
		int x=s[i]-'A';
		if(!ch[now][x]){
			ch[now][x]=++cnt;
		}now=ch[now][x];
	}
	date[now]|=(1&lt;&lt;zi);
	//cout&lt;&lt;now&lt;&lt;endl;
}
short q[N],l,r,fail[N];
void FA(){
	r=-1;
	for(int i=0;i&lt;=25;++i)ch[0][i]=1;
	q[++r]=1;
	while(l&lt;=r){
		int x=q[l];++l;
		for(int i=0;i&lt;=25;++i){
			if(ch[x][i]){
				fail[ch[x][i]]=ch[fail[x]][i];
				date[ch[x][i]]|=date[ch[fail[x]][i]];
				q[++r]=ch[x][i];
			}else{
				ch[x][i]=ch[fail[x]][i];
			}
		}
	}
}

queue&lt;int&gt;now,son;
bool vis[N][M];
char ans[N*M];
int nex[N*M];
int main(){
	cin&gt;&gt;n;cnt=1;
	for(int i=0;i&lt;n;++i){
		scanf(&quot;%s&quot;,s);
		ins(i);
	}
	FA();
	now.push(1);
	son.push(0);
	int num=0,sum=0;
	vis[0][0]=1;
	while(now.size()){
		int xnow=now.front();
		int xson=son.front();
		now.pop();
		son.pop();
		if(xson==((1&lt;&lt;n)-1)){
			int le=0;
			while(num){
				s[++le]=ans[num];
				num=nex[num];
			}
			while(le)putchar(s[le--]);
			break;
		}
		for(int i=0;i&lt;=25;++i){
			if(!vis[ch[xnow][i]][xson|date[ch[xnow][i]]]){
				vis[ch[xnow][i]][xson|date[ch[xnow][i]]]=1;
				now.push(ch[xnow][i]);
				son.push(xson|date[ch[xnow][i]]);
				nex[++sum]=num;
				ans[sum]='A'+i;
			}
		}
		++num;
	}
	system(&quot;Pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2005星际贸易][动态规划][单调队列优化][背包路径]]]></title>
        <id>https://miuyou.github.io/post/hnoi2005-xing-ji-mao-yi-dong-tai-gui-hua-dan-diao-dui-lie-you-hua-bei-bao-lu-jing/</id>
        <link href="https://miuyou.github.io/post/hnoi2005-xing-ji-mao-yi-dong-tai-gui-hua-dan-diao-dui-lie-you-hua-bei-bao-lu-jing/">
        </link>
        <updated>2020-12-26T15:09:00.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2317">P2317 [HNOI2005]星际贸易</a></li>
</ul>
<p>首先背包求出第一问,并且得到所有强制要选的点</p>
<p>那么接下来就是要最下化满足要求的路径花费</p>
<p>发现转移就俩种,要么从某个点飞过来要么原地加油,枚举某个点以及油量,复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,用单调队列搞搞就能优化成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>然鹅这题在背包部分翻车了....不该省的不要省,多重背包做不到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>的空间复杂度的</p>
<pre><code class="language-cpp">
 rd(n);rd(m);rd(RR);rd(LL);
    RR=min(RR,2*n);
    for(int i=1;i&lt;=n;++i){
        rd(a[i]);rd(b[i]);rd(l[i]);rd(p[i]);rd(f[i]);
    }
    for(int i=1;i&lt;=n;++i){
        if(l[i]-l[i-1]&gt;LL){
            puts(&quot;Poor Coke!&quot;);return 0;
        }
    }
    memset(bb,-1,sizeof(bb));
    bb[0][0]=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=0;j&lt;=m;++j){
            if(bb[i-1][j]&gt;=0)bb[i][j]=bb[i-1][j];
            if(j&gt;=a[i]&amp;&amp;bb[i-1][j-a[i]]&gt;=0){
                bb[i][j]=max(bb[i][j],bb[i-1][j-a[i]]+b[i]);
            }
        }
    }
    int an=0;int tp=0;
    for(int i=0;i&lt;=m;++i)if(bb[n][i]&gt;bb[n][an])an=i;
    for(int i=n,j=an;i;--i){
        if(bb[i][j]==bb[i-1][j])continue;
        else vis[i]=1,j-=a[i];
    }an=bb[n][an];
    
    memset(dp,0x3f,sizeof(dp));
    for(int i=0;i&lt;=RR;++i)L[i]=1;
    dp[0][RR]=0;
    q[RR][++R[RR]]=0;
    vis[n]=1;
    for(int i=1;i&lt;=n;++i){
        for(int j=0;j&lt;=RR;++j){
            if(p[i]&gt;0&amp;&amp;j&gt;0)dp[i][j]=min(dp[i][j],dp[i][j-1]+p[i]);
          
            if(L[j+2]&lt;=R[j+2])
            dp[i][j]=min(dp[i][j],dp[q[j+2][L[j+2]]][j+2]+f[i]);
            if(vis[i])L[j]=1,R[j]=0;
            while(L[j]&lt;=R[j]&amp;&amp;(dp[q[j][R[j]]][j]&gt;=dp[i][j]))--R[j];
            q[j][++R[j]]=i;
              while (L[j]&lt;=R[j]&amp;&amp;(l[i+1]-l[q[j][L[j]]]&gt;LL))++L[j];
        }
    }
    int ans=0;
    for(int i=0;i&lt;=RR;++i){if(dp[n][i]&lt;dp[n][ans])ans=i;//cout&lt;&lt;dp[n][i]&lt;&lt;endl;
    };
    if(dp[n][ans]==dp[0][0])puts(&quot;Poor Coke!&quot;);
    else printf(&quot;%d %d&quot;,an,an-dp[n][ans]);


    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[逛庙会][动态规划][状态压缩]]]></title>
        <id>https://miuyou.github.io/post/guang-miao-hui-dong-tai-gui-hua-zhuang-tai-ya-suo/</id>
        <link href="https://miuyou.github.io/post/guang-miao-hui-dong-tai-gui-hua-zhuang-tai-ya-suo/">
        </link>
        <updated>2020-12-25T14:06:44.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2238">P2238 逛庙会</a></li>
</ul>
<p>还算不错的题.....考虑俩种转移方式产生的不确定因素,将其状态压缩然后转移</p>
<pre><code class="language-cpp">
  for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]+1);
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            if(s[i][j]=='.'){
                a[i][j]=0;
            }else{
                a[i][j]=s[i][j]-'0';
            }
        }
    }
    int mn=15;
    memset(b,0x3f,sizeof(b));
    b[1][1][mn]=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            for(int x=0;x&lt;=mn;++x){
                for(int y=0;y&lt;=mn;++y){
                    if((((x&amp;4)==0)!=((y&amp;8)==0))||(!(x&amp;1))||(((x&amp;2)!=0)+((y&amp;1)!=0)+((y&amp;4)!=0)&lt;=1))continue;
                    int ans=b[i][j][x];
                    if(y&amp;4)ans+=a[i+1][j+1];
                    if(y&amp;2)ans+=a[i-1][j+2];
                    if(y&amp;1)ans+=a[i][j+2];
                    b[i][j+1][y]=min(b[i][j+1][y],ans);
                }
                for(int y=0;y&lt;=mn;++y){
                     if((((x&amp;1)==0)!=((y&amp;2)==0))||(!(x&amp;4))||(((x&amp;8)!=0)+((y&amp;1)!=0)+((y&amp;4)!=0)&lt;=1))continue;
                    int ans=b[i][j][x];
                    if(y&amp;1)ans+=a[i+1][j+1];
                    if(y&amp;4)ans+=a[i+2][j];
                    if(y&amp;8)ans+=a[i+2][j-1];
                    b[i+1][j][y]=min(b[i+1][j][y],ans);
                }
            }
        }
    }
    cout&lt;&lt;b[n][m][15]&lt;&lt;endl;

    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[SHOI2009舞会][动态规划][计数]]]></title>
        <id>https://miuyou.github.io/post/shoi2009-wu-hui-dong-tai-gui-hua-ji-shu/</id>
        <link href="https://miuyou.github.io/post/shoi2009-wu-hui-dong-tai-gui-hua-ji-shu/">
        </link>
        <updated>2020-12-24T10:53:35.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2159">P2159 [SHOI2009]舞会</a></li>
</ul>
<p>很神啊,啪的一下,我就被秒了</p>
<p>俩个轴,考虑固定男生,然后去逐位匹配女生,发现每次加入一个男生无法统计...那么考虑同时加入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,i号要么男生高,<br>
然后考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>&gt;</mo><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_j&gt;=y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>个,以及剩下的j个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>&lt;</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j&lt;y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都不需要特殊处理,再加上自己<br>
需要特殊处理的只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>&lt;</mo><mo>=</mo><msub><mi>x</mi><mi>j</mi></msub><mo>&lt;</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_j&lt;=x_j&lt;y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>s</mi><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i-s-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></p>
<p>需要着重注意一些性质,例如本题的有序性,有序是我们计数的关键条件</p>
<pre><code class="language-cpp">
rd(n);rd(k);
	for(int i=1;i&lt;=n;++i){
		rd(a[i]);
	}for(int i=1;i&lt;=n;++i){
		rd(b[i]);
	}
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;i;++j){
			c[i]+=(a[j]&gt;=b[i]);
			d[i]+=(b[j]&gt;a[i]);
		}
	}
	dp[0][0]=1;
	for(int i=1;i&lt;=n;++i){
		if(a[i]&gt;=b[i])
		for(int j=0;j&lt;=min(n,k);++j){
			SpringWait x;
			x=(c[i]+j+1);
			dp[i][j]+=x*dp[i-1][j];
			if(!j)continue;
			x=(i-c[i]-j);
			if(i-c[i]-j)
			dp[i][j]+=x*dp[i-1][j-1];
		}else{
			for(int j=1;j&lt;=min(n,k);++j){
				SpringWait x;
				x=(d[i]+i-j+1);
				dp[i][j]+=x*dp[i-1][j-1];
				x=(j-d[i]);
				if(j-d[i]&gt;0)
				dp[i][j]+=x*dp[i-1][j];
			}
		}
	}
	SpringWait ans;
	for(int i=0;i&lt;=k;++i){
		ans=(ans+dp[n][i]);
	}

    ```

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[排队打饭][动态规划][不错的状态压缩]]]></title>
        <id>https://miuyou.github.io/post/pai-dui-da-fan-dong-tai-gui-hua-bu-cuo-de-zhuang-tai-ya-suo/</id>
        <link href="https://miuyou.github.io/post/pai-dui-da-fan-dong-tai-gui-hua-bu-cuo-de-zhuang-tai-ya-suo/">
        </link>
        <updated>2020-12-23T16:09:04.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2157">P2157 [SDOI2009]学校食堂</a></li>
</ul>
<p>刚看到题目会觉得难以下手</p>
<p>考虑最难解决的是如何维护那些人吃过饭了那些人可以吃饭,发现大家的容忍度都不高,将其状态压缩,那么就可以传递那些人吃过了,然后考虑上一个是谁吃会影响到计算结果,那么再开一维记录上一个是谁,就可以转移啦.想当于每个点都要背包一下怎么选后面谁吃,然后转移到下一个人的前提是这个人吃过了.</p>
<pre><code class="language-cpp">
memset(f,0x3f,sizeof(f));
		f[1][0][7]=0;
		for(int i=1;i&lt;=n;++i){
			for(int j=0;j&lt;MAXN;++j){
				for(int k=-8;k&lt;=7;++k){
					if(f[i][j][k+8]!=f[0][0][0]){
						if(j&amp;1){
							f[i+1][j&gt;&gt;1][k+7]=min(f[i+1][j&gt;&gt;1][k+7],f[i][j][k+8]);
						}else{
							int r=f[0][0][0];
							for(int z=0;z&lt;=7;++z){
								if(j&amp;(1&lt;&lt;z))continue;
								if(i+z&gt;r)break;
								r=min(r,i+z+b[i+z]);
								f[i][j|(1&lt;&lt;z)][z+8]=min(f[i][j|(1&lt;&lt;z)][z+8],f[i][j][k+8]+((i+k)?(a[i+k]^a[i+z]):0));

							}
						}
					}
				}
			}
		}
		int ans=f[0][0][0];
		for(int i=0;i&lt;=8;++i){
			ans=min(ans,f[n+1][0][i]);
		//	cout&lt;&lt;f[n+1][0][i]&lt;&lt;endl;
		}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringWait's 置换]]></title>
        <id>https://miuyou.github.io/post/springwaits-zhi-huan/</id>
        <link href="https://miuyou.github.io/post/springwaits-zhi-huan/">
        </link>
        <updated>2020-12-22T17:11:39.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>u</mi><mi>r</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Burnside</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span> 引理： 对于一个置换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>，若一个着色方案<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 经过置换后不变，则称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的不动点。记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的不动点数目为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>，则等价类个数为所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> 的平均值。</p>
<p>例题- <a href="https://www.luogu.com.cn/problem/P1446">P1446 [HNOI2008]Cards</a></p>
<pre><code class="language-cpp">
ll n,r,b,g,m,p,a[M],f[N][N][N];
bool vis[M];
ll t[M],sum,siz[M];
inline ll work(){
	memset(vis,0,sizeof(vis));
	memset(f,0,sizeof(f));
	f[0][0][0]=1;sum=0;
	memset(siz,0,sizeof(siz));
	for(int i=1;i&lt;=n;++i){
		if(vis[i])continue;
		int x=i;
		++sum;
		while(!vis[x]){
			vis[x]=1;
			x=a[x];
			++siz[sum];
		}
	}
	for(int z=1;z&lt;=sum;++z){
		for(int i=r;~i;--i){
			for(int j=b;~j;--j){
				for(int k=g;~k;--k){
					if(i&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i-siz[z]][j][k])%p;
					if(j&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i][j-siz[z]][k])%p;
					if(k&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i][j][k-siz[z]])%p;
				}
			}
		}
	}
	return f[r][b][g];
}
inline ll ksm(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&amp;1)ans=1ll*ans*x%p;
		x=1ll*x*x%p;
		y&gt;&gt;=1;
	}return ans;
}
int main(){
	rd(r);rd(b);rd(g);rd(m);rd(p);
	n=r+b+g;
	int ans=0;
	for(int i=1;i&lt;=m;++i){
		for(int j=1;j&lt;=n;++j){
			rd(a[j]);
		}
		ans=(ans+work())%p;
	}
	for(int i=1;i&lt;=n;++i)a[i]=i;
	ans=(ans+work())%p;
	ans=1ll*ans*ksm(m+1,p-2)%p;
	cout&lt;&lt;ans&lt;&lt;endl;
}

</code></pre>
]]></content>
    </entry>
</feed>