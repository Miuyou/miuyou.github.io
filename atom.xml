<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://miuyou.github.io/</id>
    <title>春待ち</title>
    <updated>2020-12-25T14:08:48.781Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://miuyou.github.io/"/>
    <link rel="self" href="https://miuyou.github.io/atom.xml"/>
    <subtitle>开端顺利 自这天起 离乡背井 等候春息  身处何地 等候春息</subtitle>
    <logo>https://miuyou.github.io/images/avatar.png</logo>
    <icon>https://miuyou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 春待ち</rights>
    <entry>
        <title type="html"><![CDATA[[逛庙会][动态规划][状态压缩]]]></title>
        <id>https://miuyou.github.io/post/guang-miao-hui-dong-tai-gui-hua-zhuang-tai-ya-suo/</id>
        <link href="https://miuyou.github.io/post/guang-miao-hui-dong-tai-gui-hua-zhuang-tai-ya-suo/">
        </link>
        <updated>2020-12-25T14:06:44.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2238">P2238 逛庙会</a></li>
</ul>
<p>还算不错的题.....考虑俩种转移方式产生的不确定因素,将其状态压缩然后转移</p>
<pre><code class="language-cpp">
  for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]+1);
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            if(s[i][j]=='.'){
                a[i][j]=0;
            }else{
                a[i][j]=s[i][j]-'0';
            }
        }
    }
    int mn=15;
    memset(b,0x3f,sizeof(b));
    b[1][1][mn]=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j){
            for(int x=0;x&lt;=mn;++x){
                for(int y=0;y&lt;=mn;++y){
                    if((((x&amp;4)==0)!=((y&amp;8)==0))||(!(x&amp;1))||(((x&amp;2)!=0)+((y&amp;1)!=0)+((y&amp;4)!=0)&lt;=1))continue;
                    int ans=b[i][j][x];
                    if(y&amp;4)ans+=a[i+1][j+1];
                    if(y&amp;2)ans+=a[i-1][j+2];
                    if(y&amp;1)ans+=a[i][j+2];
                    b[i][j+1][y]=min(b[i][j+1][y],ans);
                }
                for(int y=0;y&lt;=mn;++y){
                     if((((x&amp;1)==0)!=((y&amp;2)==0))||(!(x&amp;4))||(((x&amp;8)!=0)+((y&amp;1)!=0)+((y&amp;4)!=0)&lt;=1))continue;
                    int ans=b[i][j][x];
                    if(y&amp;1)ans+=a[i+1][j+1];
                    if(y&amp;4)ans+=a[i+2][j];
                    if(y&amp;8)ans+=a[i+2][j-1];
                    b[i+1][j][y]=min(b[i+1][j][y],ans);
                }
            }
        }
    }
    cout&lt;&lt;b[n][m][15]&lt;&lt;endl;

    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[SHOI2009舞会][动态规划][计数]]]></title>
        <id>https://miuyou.github.io/post/shoi2009-wu-hui-dong-tai-gui-hua-ji-shu/</id>
        <link href="https://miuyou.github.io/post/shoi2009-wu-hui-dong-tai-gui-hua-ji-shu/">
        </link>
        <updated>2020-12-24T10:53:35.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2159">P2159 [SHOI2009]舞会</a></li>
</ul>
<p>很神啊,啪的一下,我就被秒了</p>
<p>俩个轴,考虑固定男生,然后去逐位匹配女生,发现每次加入一个男生无法统计...那么考虑同时加入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,i号要么男生高,<br>
然后考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>&gt;</mo><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_j&gt;=y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>个,以及剩下的j个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>&lt;</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j&lt;y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都不需要特殊处理,再加上自己<br>
需要特殊处理的只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>&lt;</mo><mo>=</mo><msub><mi>x</mi><mi>j</mi></msub><mo>&lt;</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_j&lt;=x_j&lt;y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>s</mi><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i-s-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></p>
<p>需要着重注意一些性质,例如本题的有序性,有序是我们计数的关键条件</p>
<pre><code class="language-cpp">
rd(n);rd(k);
	for(int i=1;i&lt;=n;++i){
		rd(a[i]);
	}for(int i=1;i&lt;=n;++i){
		rd(b[i]);
	}
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;i;++j){
			c[i]+=(a[j]&gt;=b[i]);
			d[i]+=(b[j]&gt;a[i]);
		}
	}
	dp[0][0]=1;
	for(int i=1;i&lt;=n;++i){
		if(a[i]&gt;=b[i])
		for(int j=0;j&lt;=min(n,k);++j){
			SpringWait x;
			x=(c[i]+j+1);
			dp[i][j]+=x*dp[i-1][j];
			if(!j)continue;
			x=(i-c[i]-j);
			if(i-c[i]-j)
			dp[i][j]+=x*dp[i-1][j-1];
		}else{
			for(int j=1;j&lt;=min(n,k);++j){
				SpringWait x;
				x=(d[i]+i-j+1);
				dp[i][j]+=x*dp[i-1][j-1];
				x=(j-d[i]);
				if(j-d[i]&gt;0)
				dp[i][j]+=x*dp[i-1][j];
			}
		}
	}
	SpringWait ans;
	for(int i=0;i&lt;=k;++i){
		ans=(ans+dp[n][i]);
	}

    ```

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[排队打饭][动态规划][不错的状态压缩]]]></title>
        <id>https://miuyou.github.io/post/pai-dui-da-fan-dong-tai-gui-hua-bu-cuo-de-zhuang-tai-ya-suo/</id>
        <link href="https://miuyou.github.io/post/pai-dui-da-fan-dong-tai-gui-hua-bu-cuo-de-zhuang-tai-ya-suo/">
        </link>
        <updated>2020-12-23T16:09:04.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2157">P2157 [SDOI2009]学校食堂</a></li>
</ul>
<p>刚看到题目会觉得难以下手</p>
<p>考虑最难解决的是如何维护那些人吃过饭了那些人可以吃饭,发现大家的容忍度都不高,将其状态压缩,那么就可以传递那些人吃过了,然后考虑上一个是谁吃会影响到计算结果,那么再开一维记录上一个是谁,就可以转移啦.想当于每个点都要背包一下怎么选后面谁吃,然后转移到下一个人的前提是这个人吃过了.</p>
<pre><code class="language-cpp">
memset(f,0x3f,sizeof(f));
		f[1][0][7]=0;
		for(int i=1;i&lt;=n;++i){
			for(int j=0;j&lt;MAXN;++j){
				for(int k=-8;k&lt;=7;++k){
					if(f[i][j][k+8]!=f[0][0][0]){
						if(j&amp;1){
							f[i+1][j&gt;&gt;1][k+7]=min(f[i+1][j&gt;&gt;1][k+7],f[i][j][k+8]);
						}else{
							int r=f[0][0][0];
							for(int z=0;z&lt;=7;++z){
								if(j&amp;(1&lt;&lt;z))continue;
								if(i+z&gt;r)break;
								r=min(r,i+z+b[i+z]);
								f[i][j|(1&lt;&lt;z)][z+8]=min(f[i][j|(1&lt;&lt;z)][z+8],f[i][j][k+8]+((i+k)?(a[i+k]^a[i+z]):0));

							}
						}
					}
				}
			}
		}
		int ans=f[0][0][0];
		for(int i=0;i&lt;=8;++i){
			ans=min(ans,f[n+1][0][i]);
		//	cout&lt;&lt;f[n+1][0][i]&lt;&lt;endl;
		}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringWait's 置换]]></title>
        <id>https://miuyou.github.io/post/springwaits-zhi-huan/</id>
        <link href="https://miuyou.github.io/post/springwaits-zhi-huan/">
        </link>
        <updated>2020-12-22T17:11:39.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>u</mi><mi>r</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Burnside</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span> 引理： 对于一个置换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>，若一个着色方案<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 经过置换后不变，则称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的不动点。记 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的不动点数目为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>，则等价类个数为所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> 的平均值。</p>
<p>例题- <a href="https://www.luogu.com.cn/problem/P1446">P1446 [HNOI2008]Cards</a></p>
<pre><code class="language-cpp">
ll n,r,b,g,m,p,a[M],f[N][N][N];
bool vis[M];
ll t[M],sum,siz[M];
inline ll work(){
	memset(vis,0,sizeof(vis));
	memset(f,0,sizeof(f));
	f[0][0][0]=1;sum=0;
	memset(siz,0,sizeof(siz));
	for(int i=1;i&lt;=n;++i){
		if(vis[i])continue;
		int x=i;
		++sum;
		while(!vis[x]){
			vis[x]=1;
			x=a[x];
			++siz[sum];
		}
	}
	for(int z=1;z&lt;=sum;++z){
		for(int i=r;~i;--i){
			for(int j=b;~j;--j){
				for(int k=g;~k;--k){
					if(i&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i-siz[z]][j][k])%p;
					if(j&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i][j-siz[z]][k])%p;
					if(k&gt;=siz[z])f[i][j][k]=(f[i][j][k]+f[i][j][k-siz[z]])%p;
				}
			}
		}
	}
	return f[r][b][g];
}
inline ll ksm(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&amp;1)ans=1ll*ans*x%p;
		x=1ll*x*x%p;
		y&gt;&gt;=1;
	}return ans;
}
int main(){
	rd(r);rd(b);rd(g);rd(m);rd(p);
	n=r+b+g;
	int ans=0;
	for(int i=1;i&lt;=m;++i){
		for(int j=1;j&lt;=n;++j){
			rd(a[j]);
		}
		ans=(ans+work())%p;
	}
	for(int i=1;i&lt;=n;++i)a[i]=i;
	ans=(ans+work())%p;
	ans=1ll*ans*ksm(m+1,p-2)%p;
	cout&lt;&lt;ans&lt;&lt;endl;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[铁马落地][动态规划][线段树优化DP]]]></title>
        <id>https://miuyou.github.io/post/tie-ma-luo-di-dong-tai-gui-hua-xian-duan-shu-you-hua-dp/</id>
        <link href="https://miuyou.github.io/post/tie-ma-luo-di-dong-tai-gui-hua-xian-duan-shu-you-hua-dp/">
        </link>
        <updated>2020-12-22T16:53:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1442">P1442 铁球落地</a></li>
</ul>
<p>先弄一个假假的想法,发现影响复杂的是快速找到下一层,那么从下往上线段树区间覆盖就好了....</p>
<pre><code class="language-cpp">
struct SpringWait{
	int h,l,r;
}a[N];
inline bool operator &lt;(SpringWait a,SpringWait b){
	return a.h&lt;b.h;
}
int t[N],num;
int f[N],g[N],ls[N],rs[N],flag[N&lt;&lt;2];
inline void pushdown(int k){
	if(flag[k]){
		flag[k&lt;&lt;1]=flag[k];
		flag[k&lt;&lt;1|1]=flag[k];
		flag[k]=0;
	}
}
inline int query(int k,int l,int r,int x){
	if(l==r)return flag[k];
	pushdown(k);
	int mid=(l+r)&gt;&gt;1;
	if(x&lt;=mid)return query(k&lt;&lt;1,l,mid,x);
	else return query(k&lt;&lt;1|1,mid+1,r,x);
}
inline void update(int k,int l,int r,int L,int R,int x){
	if(L&lt;=l&amp;&amp;r&lt;=R){
		flag[k]=x;
	}else{
		int mid=(l+r)&gt;&gt;1;
		if(L&lt;=mid)update(k&lt;&lt;1,l,mid,L,R,x);
		if(R&gt;mid)update(k&lt;&lt;1|1,mid+1,r,L,R,x);
	}
}
int main(){
	rd(n);rd(h);
	int x,y;
	rd(x);rd(y);
	for(int i=1;i&lt;=n;++i){
		rd(a[i].h);rd(a[i].l);rd(a[i].r);
		t[++num]=a[i].l;
		t[++num]=a[i].r;
	}
	++n;
	a[n].l=a[n].r=x;
	a[n].h=y;
	t[++num]=x;
	sort(a+1,a+1+n);
	sort(t+1,t+1+num);
	//num=unique(t+1,t+1+num)-t-1;
	for(int i=1;i&lt;=n;++i){
		a[i].l=lower_bound(t+1,t+1+num,a[i].l)-t;
		a[i].r=lower_bound(t+1,t+1+num,a[i].r)-t;
	}
	for(int i=1;i&lt;=n;++i){
		ls[i]=query(1,1,num,a[i].l);
		rs[i]=query(1,1,num,a[i].r);
		update(1,1,num,a[i].l,a[i].r,i);
	}
	memset(f,0x3f,sizeof(f));
	memset(g,0x3f,sizeof(g));
	f[0]=g[0]=0;
	for(int i=1;i&lt;=n;++i){
		if(a[i].h-a[ls[i]].h&lt;=h){
			if(ls[i]){
				f[i]=min(f[i],f[ls[i]]+t[a[i].l]-t[a[ls[i]].l]+a[i].h-a[ls[i]].h);
				f[i]=min(f[i],g[ls[i]]-t[a[i].l]+t[a[ls[i]].r]+a[i].h-a[ls[i]].h);
			}else{
				f[i]=a[i].h;
			}
		}

		if(a[i].h-a[rs[i]].h&lt;=h){
			if(rs[i]){
				g[i]=min(g[i],f[rs[i]]+t[a[i].r]-t[a[rs[i]].l]+a[i].h-a[rs[i]].h);
				g[i]=min(g[i],g[rs[i]]-t[a[i].r]+t[a[rs[i]].r]+a[i].h-a[rs[i]].h);
			}else{
				g[i]=a[i].h;
			}
		}
	}
	printf(&quot;%d\n&quot;,min(f[n],g[n]));
	system(&quot;Pause&quot;);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2003历史年份][动态规划][线段树优化建图]]]></title>
        <id>https://miuyou.github.io/post/hnoi2003-li-shi-nian-fen-dong-tai-gui-hua-xian-duan-shu-you-hua-jian-tu/</id>
        <link href="https://miuyou.github.io/post/hnoi2003-li-shi-nian-fen-dong-tai-gui-hua-xian-duan-shu-you-hua-jian-tu/">
        </link>
        <updated>2020-12-22T08:34:28.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P2282">P2282 [HNOI2003]历史年份</a></li>
</ul>
<p>orzzzzzzzzzzzzzzzzzzz</p>
<p>调了一天</p>
<p>让我们先把弱化版给切掉</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1415">P1415 拆分数列</a></li>
</ul>
<p>一路填表过去就好了,正着一次反着一次<br>
先求出最小后缀,发现对于每个值的左下标越靠近n越小<br>
然后倒着做回来,右下标越靠近n越nb</p>
<p>那么</p>
<pre><code class="language-cpp">

inline bool cmp(int l1,int r1,int l2,int r2){
	int len1=r1-l1+1;
	int len2=r2-l2+1;
	int s1=l1,s2=l2,e1=r1,e2=r2;
	while(!a[s1]){
		++s1;
		--len1;
	}
	while (!a[s2]){
		++s2;
		--len2;
	}
	if(len1&gt;len2)return 0;
	if(len1&lt;len2)return 1;
	for(int i=0;i&lt;len1;++i){
		if(a[s1+i]!=a[s2+i]){
			return 	a[s1+i]&lt;a[s2+i];
		}	
	}
	return 0;
}
int main(){
	scanf(&quot;%s&quot;,s+1);
	n=strlen(s+1);
	for(int i=1;i&lt;=n;++i){
		a[i]=s[i]-'0';
	}
	f[1]=1;
	for(int i=2;i&lt;=n;++i){
		for(int j=i;j;--j){
			if(cmp(f[j-1],j-1,j,i)){
				f[i]=j;break;
			}
		}
	}
	int i=n;
	while((i&gt;=f[n]||(!a[i]))&amp;&amp;i){
		g[i]=n;
		--i;
	}
	for(;i;--i){
		g[i]=i;
		for(int j=n-1;j&gt;i;--j){
			if(cmp(i,j,j+1,g[j+1])){
				g[i]=j;
				break;
			}
		}
	}
	for(int i=1;i&lt;=n;i=g[i]+1){
		for(int j=i;j&lt;=g[i];++j){
			printf(&quot;%c&quot;,s[j]);
		}
		if(g[i]!=n)printf(&quot;,&quot;);
	}


</code></pre>
<p>就好了,然鹅这个复杂度高达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,需要优化<br>
一:hash+二分代替暴力检查<br>
二:改成刷表,然后线段树优化DP</p>
<pre><code class="language-cpp">int n;
char s[N];
unsigned ll a[N],pw[N];
inline void prework(){
	n=strlen(s+1);
	for(int i=1;i&lt;=n;++i){
		a[i]=a[i-1]*md+(s[i]-'0');
	}
}
unsigned ll get(int l,int r){return a[r]-a[l-1]*pw[r-l+1];}
inline bool cmp(int l1,int r1,int l2,int r2){
	int len1=r1-l1+1;
	int len2=r2-l2+1;
	if(len1&lt;len2)return 1;
	if(len2&lt;len1)return 0;
	int l=1,r=len1,mid,ans=0;
	while(l&lt;=r){
		mid=(l+r)&gt;&gt;1;
		if(get(l1,l1+mid-1)==get(l2,l2+mid-1))l=mid+1,ans=mid;
		else r=mid-1;
	}
	if(ans&gt;=len1)return 0;
	return s[l1+ans]&lt;s[l2+ans];
}
int l[N],r[N],f,g,flag[N&lt;&lt;2],t[N&lt;&lt;2];
inline void update(int k,int l,int r,int L,int R,int val){
	if(L&lt;=l&amp;&amp;r&lt;=R){
		flag[k]=max(flag[k],val);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if(mid&gt;=L)update(k&lt;&lt;1,l,mid,L,R,val);
	if(mid&lt;R)update(k&lt;&lt;1|1,mid+1,r,L,R,val);
}
inline void pushdown(int k){
	if(flag[k]){
		flag[k&lt;&lt;1]=max(flag[k&lt;&lt;1],flag[k]);
		flag[k&lt;&lt;1|1]=max(flag[k&lt;&lt;1|1],flag[k]);
		flag[k]=0;
	}return;
}
inline int query(int k,int l,int r,int z){
	
	if(l==r){t[k]=max(t[k],flag[k]);flag[k]=0;return t[k];}
	pushdown(k);
	int mid=(l+r)&gt;&gt;1;
	if(z&lt;=mid)return query(k&lt;&lt;1,l,mid,z);
	else return query(k&lt;&lt;1|1,mid+1,r,z);
}
int main(){
	pw[0]=1ll;
	for(int i=1;i&lt;=N-5;++i)pw[i]=pw[i-1]*md;
	while(~scanf(&quot;%s&quot;,s+1)){

		prework();
		for(int i=1;i&lt;=n;++i)if(s[i]=='0')l[i]=l[i-1];else l[i]=i;
		r[n+1]=n+1;
		for(int i=n;i;--i)if(s[i]=='0')r[i]=r[i+1];else r[i]=i;
		memset(flag,0,sizeof(flag));
		memset(t,0,sizeof(t));
		update(1,1,n,r[1],n,1);
		for(int i=1;i&lt;n;++i){
			f=query(1,1,n,i);
			int nex=r[i+1]+i-r[f];
			if(!cmp(r[f],i,r[i+1],nex))++nex;
			//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot;   &quot;&lt;&lt;nex&lt;&lt;endl;
			if(nex&lt;=n)update(1,1,n,nex,n,i+1);
		}int z=query(1,1,n,n);
		//cout&lt;&lt;z&lt;&lt;endl;
		memset(flag,0,sizeof(flag));
		memset(t,0,sizeof(t));
		update(1,1,n,l[z-1]+1,n,n);
		while(z&gt;1){
			g=query(1,1,n,z);
			int k=g-r[z]+1;
			int y=l[max(z-1-k,0)]+1;
			if(!cmp(r[y],z-1,r[z],g))y=r[y]+1;
			update(1,1,n,y,z-1,z-1);
			z--;
		}
		int pos=query(1,1,n,1);
		//cout&lt;&lt;pos&lt;&lt;endl;
		for(int i=1;i&lt;=n;++i){
			putchar(s[i]);
			if(i==pos&amp;&amp;i!=n)putchar(','),pos=query(1,1,n,i+1);
		}
		puts(&quot;&quot;);
	}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NOI2013][动态规划][大模拟]]]></title>
        <id>https://miuyou.github.io/post/noi2013dong-tai-gui-hua-da-mo-ni/</id>
        <link href="https://miuyou.github.io/post/noi2013dong-tai-gui-hua-da-mo-ni/">
        </link>
        <updated>2020-12-21T11:05:29.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1398">P1398 [NOI2013]书法家</a></li>
</ul>
<p>属实脑瘫,不知道为啥挂掉了,最后提交了题解代码<br>
暴力DP,细节无数,以后闲着没事可以看看,还是有可取之处的</p>
<pre><code class="language-cpp">
for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;=m;++j){
			rd(b[i][j]);
			sum[i][j]=sum[i-1][j]+b[i][j];
		}
	}
	for(int i=0;i&lt;=8;++i)for(int j=0;j&lt;=150;++j)for(int k=0;k&lt;=150;++k)f[0][i][j][k]=INF;
	for(int i=0;i&lt;=150;++i)for(int j=0;j&lt;=150;++j)a[i][j]=INF;
	int now,pre,nex;
	now=1;
	pre=0;
	nex=2;
	int ans=INF;
	for(int k=1;k&lt;=m;++k){
		for(int i=1;i&lt;=n;++i){
			for(int j=i+1;j&lt;=n;++j){
				f[now][0][i][j]=max(f[pre][0][i][j],0)+sum[j][k]-sum[i-1][k];
			}
		}
		for(int i=1;i&lt;=n;++i){
			a[1][i]=f[pre][1][1][i];
			for(int j=2;j&lt;=i;++j){
				a[j][i]=max(a[j-1][i],f[pre][1][j][i]);
			}
		}
		
		for(int i=1;i&lt;=n;++i){
			f[now][1][i][i]=max(a[i][i],a[i-1][i-1])+b[i][k];
			for(int j=i+1;j&lt;=n;++j){
				f[now][1][i][j]=max(f[now][1][i][j-1]+sum[j][k]-sum[j-1][k],a[i][j]+sum[j][k]-sum[i-1][k]);
			}
		}

		for(int i=1;i&lt;n;++i){
			int mx=INF;
			for(int j=n-1;j&gt;=i;--j){
				mx=max(mx,f[pre][0][i][j+1]);
				f[now][1][i][j]=max(f[now][1][i][j],mx+sum[j][k]-sum[i-1][k]);
			}
		}
		for(int i=2;i&lt;=n;++i){
			int mx=INF;
			for(int j=i-1;j;--j){
				mx=max(mx,f[pre][1][j+1][i]);
				f[now][2][j][i]=max(f[pre][2][j][i],mx)+sum[i][k]-sum[j-1][k];
			}
		}


		int mx=INF;
		if(k!=1){
			for(int i=2;i&lt;=n;++i){
				for(int j=i-1;j;--j){
					mx=max(mx,f[nex][2][j][i]);
				}
			}
		}
		for(int i=1;i+1&lt;n;++i){
			for(int j=i+2;j&lt;=n;++j){
				f[now][3][i][j]=mx+sum[j][k]-sum[i-1][k];
				f[now][4][i][j]=max(f[pre][3][i][j],f[pre][4][i][j])+b[i][k]+b[j][k];
				f[now][5][i][j]=f[pre][4][i][j]+sum[j][k]-sum[i-1][k];
			}
		}


		mx=INF;
		if(k!=1){
			for(int i=1;i+1&lt;n;++i){
				for(int j=i+2;j&lt;=n;++j){
					mx=max(mx,f[nex][5][i][j]);
				}
			}
		}
		for(int i=1;i+1&lt;n;++i){
			for(int j=i+2;j&lt;=n;++j){
				f[now][6][i][j]=max(mx,f[pre][6][i][j])+b[i][k]+b[j][k];
				f[now][7][i][j]=max(f[pre][6][i][j],f[pre][7][i][j])+sum[j][k]-sum[i-1][k];
				f[now][8][i][j]=max(f[pre][7][i][j],f[pre][8][i][j])+b[i][k]+b[j][k];
				
				ans=max(ans,f[now][8][i][j]);
			}
		}
		/*for(int z=0;z&lt;9;z++){
        	for(int i=0;i&lt;=n;i++){
         	   for(int j=0;j&lt;=n;j++){
                cout&lt;&lt;f[now][z][i][j]&lt;&lt;&quot; &quot;;
        	    }cout&lt;&lt;endl;
       	 	}cout&lt;&lt;endl;
   		 } 
		cout&lt;&lt;&quot;  !!!!  &quot;&lt;&lt;endl;*/
		++now;
		++pre;
		++nex;
		if(now&gt;=3)now=0;
		if(pre&gt;=3)pre=0;
		if(nex&gt;=3)nex=0;
	}
	cout&lt;&lt;ans&lt;&lt;endl;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[花园][动态规划][状态压缩][矩阵转移]]]></title>
        <id>https://miuyou.github.io/post/hua-yuan-dong-tai-gui-hua-zhuang-tai-ya-suo-ju-zhen-zhuan-yi/</id>
        <link href="https://miuyou.github.io/post/hua-yuan-dong-tai-gui-hua-zhuang-tai-ya-suo-ju-zhen-zhuan-yi/">
        </link>
        <updated>2020-12-21T06:50:53.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1357">P1357 花园</a></li>
</ul>
<p>数据范围一看就是要矩阵快速幂<br>
考虑直接在序列上转移,发现行不通....<br>
换个角度把每一段的状态给他状压一下,求出可行性矩阵,然后加速一下</p>
<pre><code class="language-cpp">
ll n,m,k;
int list[N],num;
inline int bit(int x){
	int nm=0;
	while(x){
		if(x&amp;1)++nm;
		x&gt;&gt;=1;
	}return nm;
}

struct SpringWait{
	ll f[N][N];
	SpringWait(){memset(f,0,sizeof(f));}
}a;
inline SpringWait operator *(SpringWait x,SpringWait y){
	SpringWait z;
	for(int k=1;k&lt;=num;++k)
	for(int i=1;i&lt;=num;++i){
		for(int j=1;j&lt;=num;++j){
			z.f[i][j]=(z.f[i][j]+1ll*x.f[i][k]*y.f[k][j]%mod)%mod;
		}
	}return z;
}
inline SpringWait ksm(SpringWait x,ll y){
	SpringWait ans;
	for(int i=1;i&lt;=num;++i){
		ans.f[i][i]=1ll;
	}
	while(y){
		if(y&amp;1)ans=ans*x;
		x=x*x;
		y&gt;&gt;=1;
	}return ans;
}
int tp[N];
int main(){
	rd(n);rd(m);rd(k);
	for(int i=0;i&lt;(1&lt;&lt;m);++i)if(bit(i)&lt;=k)list[++num]=i,tp[i]=num;
	for(int i=1;i&lt;=num;++i){
		a.f[i][tp[(list[i]&gt;&gt;1)]]=1;
		a.f[i][tp[(list[i]&gt;&gt;1)|(1&lt;&lt;(m-1))]]=1;

	}

	SpringWait b=ksm(a,n);
	ll ans=0;
	for(int i=1;i&lt;=num;++i){
		ans=(ans+b.f[i][i])%mod;
	}
	printf(&quot;%lld\n&quot;,ans);
	system(&quot;Pause&quot;);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[倒逆之战]]></title>
        <id>https://miuyou.github.io/post/dao-ni-zhi-zhan/</id>
        <link href="https://miuyou.github.io/post/dao-ni-zhi-zhan/">
        </link>
        <updated>2020-12-21T05:46:38.000Z</updated>
        <content type="html"><![CDATA[<p>2020.12.21决定命运的选择</p>
<p>---- 喝了教练泡的感冒药!好耶!</p>
<p>---- 脑瘫模拟DP,死了死了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[队员分组][动态规划][二分图][01背包]]]></title>
        <id>https://miuyou.github.io/post/dui-yuan-fen-zu-dong-tai-gui-hua-er-fen-tu-01-bei-bao/</id>
        <link href="https://miuyou.github.io/post/dui-yuan-fen-zu-dong-tai-gui-hua-er-fen-tu-01-bei-bao/">
        </link>
        <updated>2020-12-20T15:41:23.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.luogu.com.cn/problem/P1285">P1285 队员分组</a></li>
</ul>
<p>仔细思考发现有向图可以转化成无向图,发现彼此冲突的点对对答案有影响,冲突点对连边,二分图性质显然,但是这个可以由多个连通图组成,彼此之间无影响,考虑分组进行01背包就做完了</p>
<pre><code class="language-cpp">
inline void dfs(int x,int fa,int se){
	col[x]=se;
	V[tsum][se].push_back(x);
	++num[tsum][se];
	for(int i=1;i&lt;=n;++i){
		if(i==fa||i==x)continue;
		if(!tu[x][i]){
			if(!col[i]){
				dfs(i,x,3-se);
			}else if(col[i]==se){
				puts(&quot;No solution&quot;);
				exit(0);
			}
		}
	}
}
int f[N][N],pre[N][N];
bool vis[N];
int main(){
	rd(n);
	for(int i=1,x;i&lt;=n;++i){
		rd(x);
		while(x){
			tu[i][x]=1;
			rd(x);
		}
	}
	for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;=n;++j){
			if(i!=j){
				if(tu[i][j]&amp;&amp;tu[j][i])continue;
				tu[i][j]=tu[i][j]=0;
			}
		}
	}
	for(int i=1;i&lt;=n;++i){
		if(!col[i]){
			++tsum;
			dfs(i,0,1);
		}
	}
	pre[0][0]=1;
	for(int i=1;i&lt;=tsum;++i){
		for(int j=1;j&lt;=n/2;++j){
			int k=j-num[i][1];
			if(k&gt;=0){if(pre[i-1][k])pre[i][j]=1;}
			k=j-num[i][2];
			if(k&gt;=0){if(pre[i-1][k])pre[i][j]=2;}
		}
	}
	int ans=n/2;
	for(int i=n/2;i;--i)if(pre[tsum][i]){ans=i;break;}
	printf(&quot;%d &quot;,ans);
	for(int i=tsum;i;--i){
		for(int j=0;j&lt;V[i][pre[i][ans]].size();++j)vis[V[i][pre[i][ans]][j]]=1;
		ans-=num[i][pre[i][ans]];
	}
	for(int i=1;i&lt;=n;++i)if(vis[i])printf(&quot;%d &quot;,i),++ans;
	printf(&quot;\n%d &quot;,n-ans);
	for(int i=1;i&lt;=n;++i)if(!vis[i])printf(&quot;%d &quot;,i);
	system(&quot;Pause&quot;);
	return 0;
}

</code></pre>
]]></content>
    </entry>
</feed>